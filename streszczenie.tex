\pdfbookmark[0]{Streszczenie}{streszczenie.1}
\begin{abstract}
Celem dokumentu jest analiza wydajności usług sieciowych implementowanych jako interfejsy programowania aplikacji, przy wykorzystaniu stosu technologicznego C\# / .NET oraz JavaScript / NodeJS. Zdecydowano się nie tylko, na porównanie efektywności realizacji podstawowych operacji wykonywanych na danych w kontekście zmiennego ruchu sieciowego oraz różnych systemów bazodanowych, ale także dokonano ewaluacji wydajności technik programowania współbieżnego, obsługi operacji asynchronicznych, wprowadzenia wzorca projektowego podziału odpowiedzialności, czy też wpływu wdrożenia systemów internetowych na odmiennych platformach chmurowych.

Ponadto, zaproponowano autorski mechanizm wyliczania czasu przechowywania wpisu w pamięci podręcznej i porównano go z szeroko wykorzystywanym mechanizmem statycznym. W odniesieniu do oceny wydajności operacji współbieżnych, zaimplementowano algorytm genetyczny dla problemu komiwojażera i zbadano liczbę wykonywanych iteracji a także współczynnik rezultatu względem rozwiązania optymalnego. Co się tyczy ewaluacji obsługi wywołań asynchronicznych, przeprowadzono ocenę efektywności natywnych klientów dla obu środowisk analizując średnich czasów pozyskiwania danych dla zmiennej liczby otrzymywanych encji bazodanowych. Jako zewnętrzne źródło pozyskiwania danych zaimplementowano odseparowaną lokalną usługę sieciową. Zbadano również wpływ wykorzystania zaawansowanego wzorca projektowego podziału odpowiedzialności, a także w jaki sposób, wprowadzenie rozbudowanych technik optymalizacji, możliwych dzięki przytoczonemu wzorcowi, wpływa na czas odpowiedzi interfejsów API na poszczególny rodzaj żądania. Na koniec, dokonano obserwacji dysproporcji pomiędzy czasem przetwarzania żądania usług sieciowych uruchamianych w dedykowanych środowiskach chmurowych, oraz na platformie typu infrastructure-as-a-service.

Przeprowadzone badania wykazały silną zależność wykorzystywanego silnika bazy danych, w odniesieniu do maksymalnego ruchu sieciowego, jaki są w stanie obsługiwać API. Ponadto, znaczącą dysproporcję dotyczącą obsługi operacji współbieżnych faworyzującą rozwiązanie bazujące na języku C\#, czy też silną korelację pomiędzy niską złożonością natywnego klienta http API języka JavaScript a wydajnością jego działania. Analizując wydajność rozwiązań pamięci podręcznej zaobserwowano przewagę autorskiego mechanizmu dla stałego poziomu natężenia generowanego w stałym czasie, przy uwzględnieniu losowego rozmieszczenia punktów unieważnień. 
\end{abstract}
\mykeywords{interfejsy programowania aplikacji, C\# .NET, JavaScript, NodeJS, mappery obiektowo-relacyjne, operacje współbieżne, operacje asynchroniczne, obsługa pamięci podręcznej, wzorzec podziału odpowiedzialności, replikacja transakcyjna, platformy chmurowe}
\clearpage

{
    \selectlanguage{english}
    \begin{abstract}
        The aim of the document is to analyze the performance of web services implemented as application programming interfaces, using the C\# / .NET and JavaScript / NodeJS technology stack. It was decided not only to compare the efficiency of basic operations performed on data in the context of variable network traffic and various database systems, but also to evaluate the performance of concurrent programming techniques, handling asynchronous tasks, introducing command-query responsibility seqregation design pattern, and also the impact of implementing Internet systems on different cloud platforms.

        Moreover, the author's mechanism for calculating the cache entry storage time was proposed and compared with the widely used static cache solution. With regard to the evaluation of the efficiency of concurrent operations, a genetic algorithm for the traveling salesman problem was implemented and the number of iterations performed as well as the result ratio were examined. As for the evaluation of asynchronous call handling, the effectiveness of native clients for both environments was assessed by analyzing the average data acquisition times for a variable number of database entities received. A separate local network web service was implemented as an external source of data acquisition. The impact of using an advanced design pattern named command-query responsibility segregation was also assessed, as well as how the introduction of extensive data optimization techniques, possible thanks to the above-mentioned pattern, affects the response time of APIs to a particular type of request. Finally, an observation was made of the disproportion between the processing time of a request for network services run in dedicated cloud environments as well as on an infrastructure-as-a-service platforms.

        The conducted research indicated a strong dependence of the database engine used in relation to the maximum network traffic that the API can handle. In addition, a significant disproportion in the handling of concurrent operations favoring a C\#-based solution, or a strong correlation between the low complexity of the native JavaScript http API client and its performance. Analyzing the efficiency of cache solutions, the advantage of the proprietary mechanism was observed for a constant level of intensity generated in a constant time, taking into account the random distribution of invalidation points.
    \end{abstract}
    \mykeywords{application programming interfaces, C\# .NET, JavaScript, NodeJS, object-relational mapping, concurrent operations, asynchronous tasks, memory cache API handling, command and query responsibility segregation, transactional replication, cloud platforms}
}