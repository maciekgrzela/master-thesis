\chapter{Projekt i implementacja œrodowiska badawczego}
\label{chap:implementacja-systemu}
W niniejszym rozdziale opisana zosta³a implementacja kluczowych funkcjonalnoœci systemu. W ramach opisu, przedstawiono elementy kodu Ÿród³owego programu wraz z ich wyjaœnieniami.

W pierwszych dwóch podrozdzia³ach, omówiona zosta³a zasada dzia³ania interfejsu programowania aplikacji. Ukazano w nich miêdzy innymi pe³ny przep³yw wykonywanych operacji w momencie wywo³ania punktu koñcowego API.

W podrozdziale trzecim, przeanalizowano koncepcjê mechanizmu zarz¹dzania stanem aplikacji oraz aktualizacji treœci bez prze³adowywania strony. Koncepcje ta, s¹ okreœlone w sposób identyczny, zarówno dla aplikacji mobilnej jak i webowej.

Nastêpne czêœci odnosz¹ siê kolejno do funkcjonalnoœci aplikacji webowej oraz mobilnej. Niektóre spoœród tych funkcjonalnoœci s¹ wspólne dla obu aplikacji, dlatego te¿ przedstawione zostan¹ tylko w kontekœcie danego elementu systemu.

Ostatni z podrozdzia³ów stanowi o implementacji graficznego interfejsu u¿ytkownika. Poza kodem Ÿród³owym widoków systemu, zaprezentowane s¹ w nim równie¿ ilustracje przedstawiaj¹ce gotowy interfejs.

\section{Interfejs programowania aplikacji (API)}
\label{sec:api-implementacja}
Zgodnie z informacjami wprowadzonymi w podrozdziale \ref{subsec:architektura-aplikacji}, interfejs programowania aplikacji API, zbudowany zosta³ w oparciu o architekturê trójwarstwow¹. W strukturze tej, po wys³aniu ¿¹dania z wykorzystaniem protoko³u hipertekstowego, zostaje ono obs³u¿one przez okreœlon¹ metodê klasy kontrolera. Metoda ta, w celu ustalenia odpowiedzi na ¿¹danie klienta, komunikowaæ siê musi z klasami ni¿szych warstw modelu, okreœlanymi jako serwisy.

Wewn¹trz klas serwisów, wykonywane s¹ operacje z dziedziny logiki biznesowej. W operacjach tych, wymagane s¹ najczêœciej dane, które metoda serwisu mog³aby przetwarzaæ. Aby te dane uzyskaæ, podobnie jak metody kontrolerów, tak i metody warstwy logiki biznesowej odwo³ywaæ siê musz¹ do klas warstw ni¿szych. Takie klasy, w kontekœcie zrealizowanego oprogramowania nazywane s¹ repozytoriami.

Mechanizm odwo³añ do klas warstw ni¿szych w celu pozyskiwania niezbêdnych do przetwarzania informacji umo¿liwia proste rozdzielenie odpowiedzialnoœci w ramach realizowanych funkcji. Ponadto, pozwala on na implementacjê elastycznego mechanizmu obs³ugi b³êdów oraz ³atwiejsze wykrywanie potencjalnych problemów.

Na listingach \ref{lst:endpoint-forward-worker}, \ref{lst:service-forward-worker} i \ref{lst:repository-forward-worker}, okreœlone zosta³y fragmenty kodu Ÿród³owego metod, dla klas z poszczególnych warstw architektury aplikacji. Wszystkie z listingów s¹ ze sob¹ powi¹zanie, poniewa¿ stanowi¹ fragmenty realizacji odpowiedzi na to samo ¿¹danie klienta.

Poni¿ej przedstawiono sposób obs³ugi ¿¹dania typu POST dla punktu koñcowego \texttt{/api/documents/forwards/worker}, odpowiedzialnego za realizacjê przekazania dokumentu pracownikowi.

Po wys³aniu ¿¹dania HTTP, dla okreœlonego w akapicie powy¿ej adresu punktu koñcowego, wykonany zostanie kod metody z listingu \ref{lst:endpoint-forward-worker}. W pierwszym wierszu tej metody, okreœlona zosta³a adnotacja \textit{(ang. Data Annotation)} dotycz¹ca typu obs³ugiwanego ¿¹dania, oraz fragmentu jego adresu. Metoda jest asynchroniczna (tj. uruchamiana jest jako oddzielny w¹tek programu i cechuje siê sekwencyjnoœci¹ realizacji operacji niezale¿nie od czasu ich trwania).

Funkcja punktu koñcowego przyjmuje jako argument zasób \textit{(ang. Resource)}. Element ten, definiuje parametry zwi¹zane z nadawc¹, odbiorc¹ oraz przekazywanym dokumentem. Wartoœæ zasobu, mo¿na przekazaæ metodzie endpoint'u poprzez zdefiniowanie cia³a ¿¹dania HTTP \textit{(ang. HTTP Body)}. W przypadku realizowanego API, cia³o ¿¹dania posiada formê obiektu JSON.

Na pocz¹tku metody, przekazany argument (zasób) poddawany jest walidacji. Walidacja mo¿e przebiec niepomyœlnie w sytuacji, w której elementy obiektu JSON bêd¹ posiada³y niepoprawne typy danych, lub wymagane wartoœci nie zostan¹ w nim zdefiniowane. Po pomyœlnym przejœciu procedury walidacji, obiekt zasobu oraz zagnie¿d¿ony w nim zasób dokumentu odwzorowywane s¹ na obiekty klas modelu danych. Pozwala to, na przekazanie ich jako parametry do metody klasy warstwy ni¿szej - serwisu.

Po uzyskaniu wartoœci zwróconej przez serwis, w metodzie kontrolera sprawdzana jest jej poprawnoœæ. W zale¿noœci od wyniku tego sprawdzenia, wysy³ana jest odpowiedŸ HTTP sygnalizuj¹ca b³¹d wykonywanej operacji lub jej powodzenie. Zgodnie ze standardem REST \textit{(ang. Representational State Transfer)}, wykorzystywanym przez system jako zbiór zasad dotycz¹cych dzia³ania API, w przypadku poprawnoœci metody punktu koñcowego dla typu operacji POST, zwracana jest pusta zawartoœæ \textit{(ang. No Content)}.

\begin{lstlisting}[label=lst:endpoint-forward-worker,caption=Kod metody punktu koñcowego przekazywania dokumentów pracownikowi, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
[HttpPost("worker")]
public async Task<IActionResult> ForwardToWorkerAsync([FromBody] ForwardToWorkerResource res) {
	
	if (!ModelState.IsValid) {
		return BadRequest(ModelState.GetModelStateErrorMessagesInfo());
	}
	
	var documentsForward = mapper.Map<ForwardToWorkerResource,DocumentsForward>(res);
	var document = mapper.Map<ForwardDocumentResource,ForwardDocument>(res.Document);
	var result = await documentsForwardService.ForwardToWorker(documentsForward, document);
	
	if (!result.Success)
		return BadRequest(result.Message);
		
	return NoContent();
}
\end{lstlisting}

W linii dziewi¹tej listingu \ref{lst:endpoint-forward-worker} metoda kontrolera API wywo³uje metodê serwisu. Linia ta, jest kluczowym fragmentem kodu Ÿród³owego punktu koñcowego, poniewa¿ w³aœnie w metodzie serwisu wykonywane s¹ operacje zwi¹zane z faktycznym przekazaniem dokumentu pracownikowi. Omawiana w nastêpnym akapicie funkcja serwisu przedstawiona jest na listingu \ref{lst:service-forward-worker}.

Do metody przekazania dokumentu, dostarczane s¹ dwa argumenty. Pierwszym z nich jest obiekt zasobu, natomiast drugi stanowi zasób faktury. Elementy te, zgodnie z informacjami przedstawionymi uprzednio, zosta³y wczeœniej przekszta³cone z obiektowej notacji JavaScript na klasy modelu danych.

Pocz¹tkowo, weryfikowane jest istnienie dokumentu w systemie na podstawie jego identyfikatora. Je¿eli dany rachunek nie zosta³ znaleziony, jest on generowany w oparciu o dane zawarte w zasobie dokumentu.

Nastêpnie, weryfikowane s¹ informacje zwi¹zane z nadawc¹ oraz adresatem faktury. Dla prawid³owego przekazania dokumentu, dane obu pracowników (tj. ich identyfikatory) musz¹ byæ prawid³owe. W sytuacji wykrycia nieprawid³owoœci dla danych o pracownikach, metoda serwisu zwraca sterowanie do metody kontrolera, przekazuj¹c nowy obiekt odpowiedzi \textit{(ang. Response)}. Gdy w obiekcie tym, przypisana zostaje w³aœciwoœæ wiadomoœci b³êdu \textit{(ang. Message)}, logiczny atrybut powodzenia wykonania funkcji \textit{(ang. Success)} przyjmuje wartoœæ \texttt{false}. Pozwala to, na okreœlenie poprawnoœci realizacji zadania serwisu wewn¹trz metody kontrolera.

Kolejno, pobierane s¹ wszystkie przekazania przypisane do dokumentu. Je¿eli ich liczba, jest wiêksza od zera, nale¿y sprawdziæ, czy osoba chc¹ca przekazaæ dokument, aktualnie znajduje siê w jego posiadaniu. W tym celu, uzyskiwany zostaje ostatni element listy przekazañ. Aby zweryfikowaæ przynale¿noœæ dokumentu do pracownika, identyfikator odbiorcy w ostatnim z przekazañ musi byæ zgodny z numerem pracownika stanowi¹cego nadawcê dla nowego przekazania. W przeciwnym razie, generowany jest obiekt odpowiedzi i przekazywane zostaje sterowanie do metody kontrolera.

W ostatnim fragmencie kodu Ÿród³owego funkcji serwisu, definiowany jest nowy obiekt przekazania dokumentu. Po jego utworzeniu, wywo³ywana zostaje metoda klasy repozytorium zapisuj¹ca przekazanie do kontekstu bazy danych. Aby zmiana danych w obrêbie kontekstu, odwzorowana zosta³a w bazie danych wykonana musi zostaæ metoda \texttt{CommitTransactionAsync} dla instancji klasy \texttt{UnitOfWork}. Klasa ta, jest implementacj¹ wzorca projektowego \textit{Jednostka pracy}, opisanego w rozdziale \ref{subsec:architektura-aplikacji}.

Instrukcj¹ koñcz¹c¹ metodê serwisu jest zwrócenie nowego obiektu odpowiedzi. W tym przypadku, obiekt ten zamiast tekstem wiadomoœci b³êdu, jest inicjalizowany struktur¹ przekazania dokumentu. Dziêki temu, atrybut poprawnoœci wykonania metody przyjmuje wartoœæ true.

\begin{lstlisting}[label=lst:service-forward-worker,caption=Kod metody serwisu przekazywania dokumentów pracownikowi, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public async Task<Response<DocumentsForward>> ForwardToWorker(DocumentsForward forward, ForwardDocument document) {		
			
	var existingDocument = await documentService.GetDocumentAsync(document.Id);
	Document documentToForward = null;
	if (!existingDocument.Success) {
			var result = await documentService.SaveAsync(document);
								
			if (!result.Success) {
					return new Response<DocumentsForward>("B³¹d zapisu dokumentu:{...}");
			}
			documentToForward = result.Type;
	}
	else {
			documentToForward = existingDocument.Type;
	}

	var existingRemitter = await workerService.GetWorkerAsync(forward.RemitterId);
	var existingRecipient = await workerService.GetWorkerAsync(forward.RecipientId);

	if (!existingRemitter.Success)
			return new Response<DocumentsForward>("Nadawca o id:{...} nie zosta³ znaleziony");

	if (!existingRecipient.Success)
			return new Response<DocumentsForward>("Odbiorca o id:{...} nie zosta³ znaleziony");
	
	var forwardsForDocument = documentToForward.DocumentsForwards.ToList();
	if (forwardsForDocument.Count != 0) {
			var lastForward = forwardsForDocument.Last();
			if (lastForward.RecipientId != existingRemitter.Type.Id)
					return new Response<DocumentsForward>("Nie jesteœ w³aœcicielem dokumentu!");	
	}
	var forwardToSave = new DocumentsForward {
			Remitter = existingRemitter.Type,
			Recipient = existingRecipient.Type,
			Document = documentToForward,
			Confirmed = true,
			Created = DateTime.Now
	};
	await documentsForwardRepository.SaveAsync(forwardToSave);
	await unitOfWork.CommitTransactionAsync();
	...
	return new Response<DocumentsForward>(forward);
\end{lstlisting}

W kodzie Ÿród³owym metody serwisu, wystêpuje odwo³anie do funkcji klasy repozytorium. Funkcje tej klasy, maj¹ za zadanie operowaæ na kontekœcie bazy danych (tj. odwzorowaniu danych z bazy w kodzie programu).

Na listingu \ref{lst:repository-forward-worker} pokazane zosta³o cia³o metody repozytorium. Element ten, odpowiedzialny jest za zapisanie do kontekstu bazodanowego nowego przekazania dokumentu.

Po wykonaniu wszystkich operacji, podobnie jak metody serwisów, tak i metoda repozytorium zwraca sterowanie do funkcji wywo³uj¹cej.

\begin{lstlisting}[label=lst:repository-forward-worker,caption=Kod metody repozytorium odpowiedzialnej za przekazywanie dokumentów pracownikowi, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public async Task SaveAsync(DocumentsForward documentsForward) {
	await context.DocumentsForwards.AddAsync(documentsForward);
}
\end{lstlisting}

\section{Uwierzytelnianie i autoryzacja u¿ytkowników}
Mechanizm uwierzytelniania i autoryzacji u¿ytkowników systemu skonstruowany zosta³ w oparciu o technologie .Net Core Identity oraz JSON Web Token. W ramach pierwszego z tych rozwi¹zañ, udostêpniane s¹ metody obs³ugi u¿ytkowników w systemie oraz mechanizmy tworzenia tokenu logowania. Drugie rozwi¹zanie, okreœla sposób autoryzacji u¿ytkownika oraz format tokenu.

Pierwsz¹ faz¹ procesu jest wys³anie przez klienta ¿¹dania HTTP pod adres punktu koñcowego odpowiedzialnego za logowanie. W ¿¹daniu tym, okreœlone musi zostaæ jego cia³o, zawieraj¹ce dane uwierzytelniaj¹ce.

Je¿eli dane te s¹ poprawne, interfejs API w odpowiedzi zwraca wygenerowany token u¿ytkownika.

Klient (tj. aplikacja webowa lub mobilna) wywo³uje punkty koñcowe API, za³¹czaj¹c token autoryzuj¹cy w nag³ówku komunikatu protoko³u hipertekstowego. Token ten, bêdzie autoryzowany przez interfejs tak d³ugo, jak d³ugo bêdzie trwaæ jego wa¿noœæ. Dla zrealizowanego oprogramowania czas wa¿noœci tokenu okreœlony zosta³ na jeden dzieñ.

W poni¿szych akapitach, przedstawiona zosta³a implementacja omówionego procesu w ramach interfejsu programowania aplikacji. Na listingu \ref{lst:endpoint-login} ukazano kod Ÿród³owy metody \texttt{Login} klasy \texttt{WorkersController}, która pe³ni rolê punktu koñcowego dla logowania w systemie.

Podobnie jak w przypadku punktu koñcowego realizuj¹cego przekazania dokumentów, przed cia³em metody okreœlony jest rodzaj ¿¹dania wywo³uj¹cego oraz nazwa endpointu. Ponadto, dodana zosta³a adnotacja \texttt{AllowAnonymous}, informuj¹ca o mo¿liwoœci wywo³ania punktu koñcowego bez uprzedniej autoryzacji.

W ramach metody kontrolera, pocz¹tkowo sprawdzana jest poprawnoœæ przekazanego jako parametr zasobu. Zasób ten, zawiera dane, za pomoc¹ których u¿ytkownik chce siê uwierzytelniæ. Aby dane te mog³y byæ przetwarzane, musz¹ zostaæ odwzorowywane na instancjê klasy modelu danych interfejsu API.

\begin{lstlisting}[label=lst:endpoint-login,caption=Kod metody punktu koñcowego logowania pracownika, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
[AllowAnonymous]
[HttpPost("login")]
public async Task<ActionResult> Login([FromBody] LoginCredentialsResource loginResource) {
	if (!ModelState.IsValid)
		return BadRequest(ModelState.GetModelStateErrorMessagesInfo());

	var loginCredential = mapper.Map<LoginCredentialsResource, LoginCredential>(loginResource);
	var result = await workerService.Login(loginCredential);

	if (!result.Success) return Unauthorized(result.Message);

	var resource = mapper.Map<LoggedWorker, LoggedWorkerResource>(result.Type);
	return Ok(resource);
}
\end{lstlisting}

Nastêpnym krokiem jest odwo³anie siê do metody klasy serwisu, realizuj¹cej faktyczn¹ procedurê uwierzytelniania. Kod Ÿród³owy tej metody pokazany zosta³ na listingu \ref{lst:service-login}. W zale¿noœci od wyniku zwróconego przez czêœæ sk³adow¹ serwisu, u¿ytkownikowi przekazywany jest okreœlony typ odpowiedzi HTTP.

Metoda klasy serwisu, obs³uguj¹ca procedurê logowania przyjmuje jako parametr obiekt informacji uwierzytelniaj¹cych. Na jego podstawie, z wykorzystaniem klasy \texttt{UserManager} dostêpnej w ramach biblioteki .Net Core Identity, sprawdzane jest istnienie u¿ytkownika oraz zgodnoœæ przekazanych przez niego danych.

W przypadku poprawnoœci dostarczonych przez u¿ytkownika informacji, tworzony zostaje obiekt parametrów pracownika, bêd¹cy wartoœci¹ zwracan¹ z metody serwisu. Obiekt ten, poza danymi pracownika, posiada tak¿e wygenerowany token autoryzuj¹cy.

Po odwzorowaniu zwróconej struktury na klasê zasobu, jest ona przekazywana jako odpowiedŸ na ¿¹danie klienta.

\begin{lstlisting}[label=lst:service-login,caption=Kod metody klasy serwisu realizuj¹cego procedurê logowania, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public async Task<Response<LoggedWorker>> Login(LoginCredential loginCredential) {
	var worker = await workerManager.Users
			.Include(p => p.Vehicle)
			.Include(p => p.JobPosition)
			.Include(p => p.WorkersPrivileges)
			.ThenInclude(p => p.Privilege)
			.SingleOrDefaultAsync(w => w.UserName == loginCredential.UserName);

	if (worker == null)
			return new Response<LoggedWorker>("Pracownik:[...] nie zosta³ znaleziony");

	var result = await signInManager.CheckPasswordSignInAsync(worker, loginCredential.Password, false);

	if (result.Succeeded) {
			var loggedWorker = new LoggedWorker {
					Id = worker.Id,
					FirstName = worker.FirstName,
					LastName = worker.LastName,
					...
					Token = jwtGenerator.CreateToken(worker)
			};
			return new Response<LoggedWorker>(loggedWorker);
	}
	return new Response<LoggedWorker>("Dane uwierzytelniaj¹ce s¹ niepoprawne");
}
\end{lstlisting}
\section{Zarz¹dzanie stanem aplikacji}
\label{sec:zarzadzanie-stanem}
Pojêcie systemu zarz¹dzania stanem odnosi siê do czêœci klienckiej przygotowanego oprogramowania (tj. aplikacji mobilnej oraz webowej). W przypadku obu z tych elementów, wykorzystany zosta³ hybrydowy model przechowywania stanu aplikacji, wykorzystuj¹cy zarówno koncepcjê stanu wewnêtrznego poszczególnych komponentów, jak i stanu zewnêtrznego, wspólnego dla wszystkich elementów aplikacji. Obiekty zawarte w wewnêtrznych stanach komponentów, wykorzystywane s¹ do realizacji operacji unikalnych dla ka¿dego z elementów sk³adowych aplikacji. W ramach stanu zewnêtrznego natomiast, przechowywane informacje s¹ przetwarzane przez wiele niezale¿nych od siebie komponentów.  

Zarówno dla aplikacji webowej, jak i mobilnej, jako system zarz¹dzania stanem (tj. stanem zewnêtrznym) wybrana zosta³a biblioteka MobX.

\subsection{Struktura mechanizmu zarz¹dzania stanem zewnêtrznym}
W zakresie stanu zewnêtrznego, zdefiniowana zosta³a klasa g³ównego magazynu \textit{(ang. RootStore)}, dla której atrybutami s¹ instancje wszystkich pozosta³ych magazynów podrzêdnych. Klasy podrzêdne natomiast, maj¹ za zadanie przechowywaæ elementy stanu.

Utworzone magazyny podrzêdne, zawieraj¹ w sobie fragmenty stanu, odpowiadaj¹ce wybranym funkcjonalnoœciom aplikacji. Dla przyk³adu, w ramach klasy \textit{WorkersStore} przechowywana jest miêdzy innymi lista wszystkich pracowników, a tak¿e wszystkie notatki pracownicze. Z kolei w magazynie \textit{AlgorithmsStore} gromadzone s¹ informacje odnoœnie wyniku planowania trasy dostawy.

Aby dane z klas-magazynów mog³y zostaæ wykorzystane w dowolnym komponencie, ca³a struktura klas musi staæ siê elementem ogólnodostêpnym w ramach aplikacji. Wymaganie to, jest realizowane poprzez wykorzystanie mechanizmu kontekstu. Mechanizm ten, reprezentuje strukturê danych osi¹galn¹ dla ka¿dego z fragmentów aplikacji. Do struktury tej, dodawana jest nowa instancja klasy \textit{RootStore}.

\subsection{Odœwie¿anie widoków w zale¿noœci od zmiany stanu}
Podstawowym celem modyfikacji danych w obrêbie klasy magazynu jest aktualizacja widoku aplikacji. W ramach omawianych elementów systemu proces odœwie¿ania widoków przebiega nastêpuj¹co:
\begin{itemize}
	\item Wywo³anie funkcji w ramach okreœlonego komponentu.
	\item Odwo³anie siê funkcji komponentu do akcji konkretnego magazynu.
	\item Modyfikacja w³aœciwoœci obserwowalnej, bêd¹cej elementem stanu, wewn¹trz akcji magazynu.
	\item Opcjonalne ustalenie wartoœci dla powi¹zanej z elementem obserwowalnym, w³aœciwoœci wyliczanej.
	\item Odœwie¿enie widoku wewn¹trz komponentu.
\end{itemize}

\section{Aktualizacja treœci "`na ¿ywo"'}
W obszarze funkcjonalnoœci œledzenia dokumentów oraz komunikatora tekstowego zaimplementowany zosta³ mechanizm aktualizacji treœci "`na ¿ywo"'. W ramach jego dzia³ania, u¿ytkownik jest na bie¿¹co informowany o nowych wiadomoœciach przychodz¹cych czy te¿ zmianach statusu dokumentów.

Do realizacji opisywanego modu³u wykorzystany zosta³ protokó³ WebSockets. Protokó³ ten, pozwala na dwukierunkow¹ komunikacjê pomiêdzy serwerem a klientem (tj. przegl¹dark¹ lub aplikacj¹ mobiln¹). W przeciwieñstwie do rozwi¹zañ takich jak odpytywanie HTTP \textit{(ang. HTTP Polling)}, WebSockets umo¿liwia wysy³anie wiadomoœci z serwera, bez uprzedniego otrzymania ¿¹dania klienta. Zastosowanie tego protoko³u, dostarcza mo¿liwoœæ informowania klienta o zachodz¹cych zmianach w modelu danych, nad którymi kontrolê sprawuje serwer.

W zrealizowanym oprogramowaniu, wykorzystana zosta³a biblioteka firmy Microsoft, obs³uguj¹ca komunikacjê dla protoko³u WebSockets. Biblioteka ta, nazwana SignalR dostarcza zbiór metod, pozwalaj¹cych na kontrolê transmisji danych, zarówno po stronie serwera jak i klienta.

Komunikacjê WebSockets, w ramach stworzonego systemu, mo¿na opisaæ za pomoc¹ nastêpuj¹cej sekwencji:
\begin{itemize}
\item Aplikacja kliencka inicjuje po³¹czenie z wykorzystaniem protoko³u gniazd sieciowych, wysy³aj¹c okreœlone ¿¹danie do serwera.
\item Serwer zestawia po³¹czenie z aplikacj¹ przegl¹darkow¹. 
\item Aplikacja, w czasie realizacji okreœlonej funkcjonalnoœci, wywo³uje metodê serwera która ma zostaæ wykonana.
\item Serwer wykonuje kod wywo³anej metody, a nastêpnie powiadamia o tym fakcie, okreœlony zbiór lub wszystkich klientów aktualnie z nim po³¹czonych. 
\item Ka¿dy z klientów nas³uchuje na odpowiedŸ z serwera, zwi¹zan¹ z wykonaniem okreœlonego zadania. Jeœli ta odpowiedŸ nadejdzie, aplikacje klienckie wykonuj¹ ustalony kod programu.
\end{itemize}

W celu zaprezentowania sposobu dzia³ania mechanizmu aktualizacji treœci z wykorzystaniem protoko³u gniazd sieciowych, przedstawiona zosta³a implementacja funkcjonalnoœci wewnêtrznego komunikatora tekstowego. Funkcjonalnoœæ t¹, zrealizowano w sposób analogiczny, dla aplikacji webowej oraz mobilnej. W niniejszym podrozdziale, zaprezentowany zostanie kod Ÿród³owy aplikacji webowej.

Aby skorzystaæ z komunikatora tekstowego, nale¿y przejœæ do okreœlonego widoku aplikacji. Uruchomienie tego widoku, powoduje wywo³anie akcji \texttt{createHubConnection} z klasy magazynu \texttt{MessagesStore}. Zadaniem tej akcji, jest ustanowienie po³¹czenia z wykorzystaniem protoko³u WebSockets pomiêdzy aplikacj¹ a serwerem. Na listingu \ref{lst:msg-initHub} zaprezentowano kod Ÿród³owy omawianej funkcji.

W celu ustanowienia komunikacji tworzony jest obiekt \texttt{HubConnection}, z wykorzystaniem wzorca budowniczego oraz klasy \texttt{HubConnectionBuilder}. W ramach tego obiektu, okreœlany zostaje adres serwera (przechowywany w zmiennej œrodowiskowej aplikacji), token autoryzuj¹cy, typ wyœwietlanych komunikatów informacyjnych oraz opcja automatycznego ponawiania po³¹czenia. Nastêpnie, wykonywana jest metoda \texttt{start}, wysy³aj¹ca ¿¹danie inicjuj¹ce do serwera. Wyj¹tki, zwi¹zane z niepowodzeniem ustanowienia wymiany danych, obs³ugiwane s¹ poprzez funkcje \texttt{catch}.

\begin{lstlisting}[label=lst:msg-initHub,caption=Kod metody inicjuj¹cej po³¹czenie WebSocket dla komunikatora tekstowego, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
@action createHubConnection = () => {
	this.hubConnection = new HubConnectionBuilder()
		.withUrl(process.env.REACT_APP_HUB_URL, {
			accessTokenFactory: () => window.localStorage.getItem('jwt'),
		}).configureLogging(LogLevel.None)
		.withAutomaticReconnect()
		.build();

	this.hubConnection.start()
		.catch(() =>
			toast.error('Utracono po³¹czenie z powiadomieniami na ¿ywo. Odœwie¿ stronê w celu ponownego po³¹czenia')
		);
};
\end{lstlisting}

Po zestawieniu po³¹czenia pomiêdzy elementami systemu, u¿ytkownik wybiera uczestnika konwersacji. Wybór ten, skutkuje wykonaniem metody \texttt{prepareConversation} przedstawionej na listingu \ref{lst:msg-prepare-worker}.

Parametr procedury, identyfikowany jako \texttt{worker} okreœla zbiór danych dotycz¹cych wybranego uczestnika rozmowy.

Aby wymieniane wiadomoœci, widoczne by³y tylko w obszarze odbiorcy oraz nadawcy, w czasie ka¿dej z konwersacji utworzona musi zostaæ dwuosobowa grupa uczestników rozmowy. Rozwi¹zanie to, pozwala serwerowi ustaliæ, do których klientów powinien on wys³aæ informacjê o wyst¹pieniu zdarzenia wys³ania wiadomoœci.

Dla ka¿dej z tworzonych grup, zdefiniowany musi zostaæ identyfikator, znany zarówno przez nadawcê jak i odbiorcê wiadomoœci. W zwi¹zku z faktem, ¿e obaj u¿ytkownicy posiadaj¹, wewn¹trz metody \texttt{prepareConversation} dane drugiego z uczestników rozmowy, identyfikator grupy okreœlony zosta³ jako sortowane leksykograficznie z³¹czenie kodów identyfikacyjnych dwóch pracowników.

Z chwil¹ ustalenia nazwy grupy, wywo³ywane s¹ metody przyporz¹dkowuj¹ce wyznaczone wartoœci do w³aœciwoœci obserwowalnych. Kolejno, realizowane jest wykonanie procedury serwera z wykorzystaniem komunikacji WebSockets. Nastêpnie, pobierana zostaje lista wszystkich wiadomoœci pomiêdzy dwoma u¿ytkownikami oraz ustawienie ich statusu jako "`Przeczytane"'. Operacje te, determinuj¹ aktualizacjê widoku aplikacji klienta.

\begin{lstlisting}[label=lst:msg-prepare-worker,caption=Kod metody wyboru uczestnika konwersacji tekstowej, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
const prepareConversation = (worker) => {
	let idsOrder = user.id.localeCompare(worker.id);
	let groupName = idsOrder === 1 ? `{user.id}{worker.id}`:`{worker.id}{user.id}`;
	messagesStore.selectConversationUsers(user, worker);
	messagesStore.selectGroupName(groupName);
	messagesStore.loadMessagesBetween(worker.id, user.id);
	setMessagesRead(worker);
};
\end{lstlisting}

Po po³¹czeniu u¿ytkowników w grupy, dokonywane mo¿e zostaæ faktyczne przekazywanie wiadomoœci pomiêdzy nimi. Na listingu \ref{lst:add-message} przedstawiona zosta³a akcja klasy magazynu odpowiedzialna za utworzenie nowej wiadomoœci.

Pocz¹tkowo, konstruowany jest obiekt zasobu, przechowuj¹cy informacje o nowym elemencie konwersacji. Nastêpnie, wywo³ywana zostaje zdalna metoda serwera, obs³uguj¹ca funkcjonalnoœæ tworzenia wiadomoœci. Je¿eli w trakcie jej wykonywania wyst¹pi b³¹d, wyœwietlony zostanie komunikat informuj¹cy u¿ytkownika o tym fakcie.

\begin{lstlisting}[label=lst:add-message,caption=Kod akcji utworzenia nowej wiadomoœci tekstowej, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
@action addMessage = async (message) => {
	let resource = {
		fromWorkerId: this.conversationSelectedUser.id,
		toWorkerId: this.conversationSelectedRemoteUser.id,
		message: `{message.message} @{message.mention}`
		received: false,
	};

	await this.hubConnection
		.invoke('SaveConversation', resource, this.groupName)
		.catch(() =>
			toast.error('Nie uda³o siê wys³aæ wiadomoœci. Spróbuj ponownie póŸniej'));
	...
};
\end{lstlisting}

Zadaniem zdalnej metody \texttt{SaveConversation}, do której odwo³uje siê funkcja z listingu \ref{lst:add-message} jest wprowadzenie do bazy danych nowej wiadomoœci. W dalszej kolejnoœci, po wykonaniu tego zadania, klienci musz¹ zostaæ o tym fakcie poinformowani. Dlatego te¿, wewn¹trz wspomnianej procedury, nastêpuje wys³anie komunikatów z serwera do klientów. Komunikaty wysy³ane s¹ zarówno do zdefiniowanej uprzednio grupy (wymusza to odœwie¿enie listy wszystkich wiadomoœci), jak i do pozosta³ych odbiorców. Dziêki temu, odbiorca nie korzystaj¹cy aktualnie z modu³u wiadomoœci bêdzie powiadomiony o pojawieniu siê nowego fragmentu konwersacji. Kod procedury \texttt{SaveConversation} ukazany zosta³ na listingu \ref{lst:server-save-message}.

\begin{lstlisting}[label=lst:server-save-message,caption=Kod metody serwera realizuj¹cej utworzenie nowej wiadomoœci tekstowej, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public async Task SaveConversation(SaveConversationItemResource resource, string group) {
	var item = mapper.Map<SaveConversationItemResource, ConversationItem>(resource);
	var msgItem = await conversationItemService.SaveAsync(item);
	if (!msgItem.Success)
	{
			throw new HttpRequestException(msgItem.Message);
	}

	var response = mapper.Map<ConversationItem, ConversationItemResource>(msgItem.Type);

	await Clients.Group(group).SendAsync("ReceiveConversationItem", response);
	await Clients.All.SendAsync("ReceiveConversationNotification", response);
}
\end{lstlisting}

\section{Aplikacja webowa}
\subsection{Przekazywanie dokumentów}
Modu³ przekazywania dokumentów stanowi kluczow¹ funkcjonalnoœæ przygotowanego oprogramowania. W jego obszarze, wyró¿niæ mo¿na nastêpuj¹ce elementy: przekazanie dokumentu pracownikowi, przekazanie dokumentu klientowi oraz zwrócenie dokumentu do dzia³u sprzeda¿y.

Dla pierwszego typu przekazañ, pracownik-nadawca, z wykorzystaniem obrazu kamery internetowej lub rêcznego czytnika kodów, skanuje barkod uwierzytelniaj¹cy pracownika-odbiorcy. Nastêpnie sczytywane s¹ kody wszystkich dokumentów, które maj¹ zostaæ przekazane. Aby operacja skanowania przebieg³a pomyœlnie, struktury QR, zarówno pracownika jak i dokumentów musz¹ posiadaæ odpowiednie formaty danych.

Pracownik przekazuj¹cy dokumenty, po uwierzytelnieniu nadawcy, posiada okreœlony w konfiguracji systemu czas, w którym zeskanowaæ mo¿e przekazywane faktury. Domyœln¹ wartoœci¹ tego czasu jest 30 sekund, jednak¿e liczba ta mo¿e byæ modyfikowana przez osobê posiadaj¹c¹ uprawnienia do zmiany danych konfiguracyjnych.

Ponadto, zdefiniowane zosta³y okreœlone formaty numerów dokumentów. Je¿eli numer skanowanego dokumentu nie pasuje do ¿adnego ze schematów, nie zostanie on przekazany pracownikowi.

Drugi element omawianego modu³u, stanowi funkcjonalnoœæ przekazywania dokumentów klientowi. Zasada realizacji tej funkcjonalnoœci, oraz wszystkie ograniczenia z ni¹ zwi¹zane s¹ analogiczne do elementu przekazywania dokumentu pracownikowi. Istotn¹ ró¿nic¹, pomiêdzy tymi funkcjonalnoœciami, jest brak koniecznoœci wyboru pracownika w trakcie procesu przekazywania faktur.

Struktury danych, definiuj¹ce pojedyncze przekazanie dokumentu s¹ identyczne dla obu funkcjonalnoœci. W przypadku gdy odbiorc¹ faktury jest klient, jego identyfikator wewn¹trz tej struktury, przybiera wartoœæ nieokreœlon¹ \texttt{null}.

Trzeci z wymienionych rodzajów transferów dokumentów, czyli zwrot dokumentów do dzia³u sprzeda¿y, jest modyfikacj¹ pierwszego z typów przekazañ. Stanowisko dzia³u sprzeda¿y jest traktowane w systemie w sposób odrêbny, w przeciwieñstwie do pozosta³ych rodzajów funkcji pracowniczych. Charakteryzuje siê ono, mo¿liwoœci¹ przypisania do niego tylko jednego pracownika.

Dlatego te¿, element zwrotu dokumentu do dzia³u sprzeda¿y jest w rzeczywistoœci funkcjonalnoœci¹ przekazania dokumentu pracownikowi, w którym odbiorca faktury jest z góry okreœlony.

W niniejszym rozdziale przedstawiona zostanie implementacja funkcji transferu dokumentów miêdzy pracownikami.

Na listingu \ref{lst:forward-worker-handle-worker} zilustrowany zosta³ kod Ÿród³owy operacji, wykonywanej w momencie zeskanowania barkodu QR pracownika.

Dane zawarte wewn¹trz barkodu reprezentowane s¹ w funkcji jako parametr \texttt{data}. Pierwsz¹ operacj¹, jest sprawdzenie, czy dane te nie posiadaj¹ wartoœci nieokreœlonej. Nastêpnie, dokonywana jest konwersja informacji o pracowniku na format obiektowej notacji JavaScipt. Pozwala to, na wykorzystanie tych informacji jako parametr ¿¹dania API. W ramach odpowiedzi interfejsu uzyskiwany jest obiekt parametrów pracownika. Dziêki temu, wiadomym jest ¿e odbiorca jest faktycznym u¿ytkownikiem systemu.

W dalszej kolejnoœci, dokonywane jest porównanie identyfikatorów pracowników, w celu wyeliminowania mo¿liwoœci przekazania faktury samemu sobie. Je¿eli numery identyfikacyjne aktualnie zalogowanego u¿ytkownika oraz odbiorcy s¹ ró¿ne, nastêpuje okreœlenie odbiorcy, a tak¿e zmiana wartoœci zmiennych stanu wewnêtrznego determinuj¹cych aktywnoœæ ustalonych fragmentów widoku.

Wszystkie z opisanych operacji, zawarte s¹ wewn¹trz bloku zg³aszania wyj¹tków, dlatego te¿, w sytuacji wyst¹pienia niespodziewanego b³êdu, u¿ytkownik zostanie o tym fakcie poinformowany.

\begin{lstlisting}[label=lst:forward-worker-handle-worker,caption=Kod funkcji wykonywanej po zeskanowaniu barkodu pracownika, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
const handleScannedWorker = (data) => {
	if (data !== null) {
		try {
			let json = JSON.parse(data);
			httpClient.Workers.listOneByUserName(json.userName);
			.then((response) => {
				if (response.id === user.id) {
					setCameraOneMessage('Nie mo¿na przekazaæ sobie dokumentu');
				} else {
					setChosenWorker(response);
					setCameraOneScanned(true);
					setCameraOneEnabled(false);
					setCameraOneMessage('Zeskanowano kod pracownika...');
					setActiveForm(1);
				}
			})
			.catch(() => {
				toast.error('Brak pracownika o podanym loginie');
			});
		} catch (e) {
			toast.error('Wyst¹pi³ b³¹d skanowania');
		}
	}
};
\end{lstlisting}

Po pomyœlnym zweryfikowaniu danych odbiorcy, wykonywane zostaje skanowanie dokumentów. Na listingu \ref{lst:forward-worker-handle-document} przedstawiony zosta³ kod metody, uruchamianej po sczytaniu danych faktury.

Podobnie jak przy weryfikacji informacji o pracowniku, sprawdzana jest zawartoœæ danych pod kontem wartoœci nieokreœlonej, a tak¿e wykonywana jest konwersja na format JSON. Nastêpnie, identyfikowany zostaje parametr "`s"', oznaczaj¹cy w formacie kodu, numer dokumentu. Stanowi to rodzaj weryfikacji danych faktury po stronie klienta. W kolejnym kroku, aktualnie przechowywany zbiór dokumentów do przekazania jest analizowany pod kontem wystêpowania w nim aktualnie sczytanej faktury. Je¿eli faktury tej nie ma w zbiorze, mo¿e ona zostaæ do niego dodana. W przeciwnym razie, wyœwietlony zostaje stosowny komunikat.

\begin{lstlisting}[label=lst:forward-worker-handle-document,caption=Kod funkcji wykonywanej po zeskanowaniu barkodu dokumentu, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
const handleScannedInvoice = (data) => {
	if (data !== null) {
		try {
			let json = JSON.parse(data);
			if (json.hasOwnProperty('s')) {
				let documents = scannedDocuments;
				let found = documents.filter((d) => d.s === json.s);
				if (found.length === 0) {
					setScannedDocuments([...documents, json]);
				} else {
					setCameraTwoMessage('Dokument zosta³ ju¿ zeskanowany');
					setTimeout(() => {
					setCameraTwoMessage('Zeskanuj kod przekazywanego dokumentu');
					}, 1000);
				}
			} else {
				setCameraTwoMessage('Kod QR nie odnosi siê do dokumentu');
			}
		} catch (e) {
			setCameraTwoMessage('Struktura kodu jest niepoprawna');
		}
	}
};
\end{lstlisting}

Nastêpnym krokiem, po okreœleniu niezbêdnych do realizacji przekazania informacji, jest wprowadzenie do bazy danych wpisów definiuj¹cych transfery faktur. Na listingu \ref{lst:forward-worker-handle-pass}, pokazany zosta³ kod funkcji, odpowiedzialnej za przygotowanie danych oraz wywo³anie ¿¹dania interfejsu API. Interfejs ten, w ramach jednego z punktów koñcowych, wykona operacjê wprowadzenia wpisów przekazañ dokumentów.

Pierwszym elementem funkcji z listingu \ref{lst:forward-worker-handle-pass}, jest zdefiniowanie zasobu dokumentu na podstawie danych barkodu. Nastêpnie, dokument ten staje siê elementem obiektu przekazania, który pe³ni rolê zasobu nadrzêdnego. Kolejno, wykonywana jest metoda \texttt{forwardToWorker}, której zadaniem jest wygenerowanie ¿¹dania do interfejsu API. Wszystkie z tych operacji, przeprowadzane s¹ wewn¹trz asynchronicznej pêtli \texttt{forEach}. Pozwala to na zachowanie kolejnoœci wprowadzania przekazañ, oraz ustalenie sekwencyjnoœci d³ugo trwaj¹cych operacji. Po zakoñczeniu pêtli, ³adowane s¹ wszystkie wiadomoœci dotycz¹ce ewentualnych b³êdów zwi¹zanych z przekazaniami.

\begin{lstlisting}[label=lst:forward-worker-handle-pass,caption=Kod funkcji przekazania dokumentów, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
const handleDocumentsPass = async () => {
	await forEachAsync(scannedDocuments, async (scan) => {
		let document = {
			id: scan.s,
			clientSymbol: scan.c !== undefined ? scan.c : null,
			deliveryPointSymbol: scan.dp !== undefined ? scan.dp : null,
			paymentMethodSymbol: scan.pm !== undefined ? scan.pm : null,
			grossPrice: scan.pr !== undefined ? parseFloat(scan.pr) : null,
			paymentTimeout: scan.ti !== undefined ? Number(scan.ti) : null,
		};

		let resource = {
			remitterId: user.id,
			recipientId: chosenWorker.id,
			document: document,
			comment: null,
			confirmed: true,
		};

		await forwardToWorker(resource);
	});
	loadErrorMessages();
	setErrorMessagesLoaded(true);
};
\end{lstlisting}

Przedstawiony powy¿ej kod, jest ostatnim elementem modu³u transferu dokumentów w obszarze aplikacji klienckiej. W odniesieniu do dziedziny interfejsu API, fragment procedury przekazania dokumentu przedstawiony zosta³ szczegó³owo w podrozdziale \ref{sec:api-implementacja}.

\subsection{Œledzenie dokumentów}
Ide¹ modu³u œledzenia dokumentów jest mo¿liwoœæ dostarczenia informacji o stanie faktur, zarówno tych aktualnie przekazywanych, jak i archiwalnych. Opisywany fragment oprogramowania zawiera dwie funkcjonalnoœci (tj. przegl¹danie dokumentów oraz przegl¹danie archiwum).

W ramach przegl¹du dokumentów, u¿ytkownikowi ukazywany jest widok tabelaryczny, w którym kolejne z wierszy tabeli reprezentuj¹ poszczególne faktury. Dla ka¿dego z poœwiadczeñ sprzeda¿y, okreœlony jest jego aktualny stan. Dziêki temu rozwi¹zaniu, pracownik jest w stanie oceniæ, czy dokument znajduje siê u któregoœ ze wspó³pracowników, czy te¿ zosta³ przekazany klientowi.

Ponadto, w widoku zawarte s¹ informacje charakteryzuj¹ce fakturê (tj. symbol, dane kontrahenta oraz sposób p³atnoœci). Co wiêcej, opisywany element interfejsu dostarcza funkcjonalnoœæ wprowadzenia oraz przegl¹dania uwag i wyjaœnieñ zwi¹zanych z dokumentem.

Dane, zawarte wewn¹trz modu³u przegl¹dania dokumentów, aktualizowane s¹ bez odœwie¿ania widoku, dziêki implementacji komunikacji z wykorzystaniem protoko³u gniazd sieciowych.

Funkcjonalnoœæ przegl¹dania dokumentów archiwalnych, ma za zadanie zapewniæ mo¿liwoœæ rozstrzygania kwestii spornych, dotycz¹cych faktu dostarczenia poœwiadczenia sprzeda¿y do klienta.

Wszystkie faktury, których stan okreœlony jest jako "`Przekazano klientowi"', w dniu nastêpnym wprowadzone zostaj¹ do archiwum.

W ramach widoku archiwum, dostêpne s¹ te same dane, co w przypadku przegl¹dania aktualnie przekazywanych dokumentów.

\subsection{Nadzorowanie dostawców}
Modu³ nadzorowania dostawców zawiera w sobie funkcjonalnoœci: monitorowania trasy dostawcy, przegl¹dania wpisów kilometrów, przegl¹dania historii lokalizacji pracowników oraz przegl¹dania notatek handlowych.

Funkcjonalnoœæ monitorowania trasy dostawcy pozwala:
\begin{itemize}
	\item Badaæ aktualn¹ lokalizacjê danego pracownika
	\item Obserwowaæ status dokumentów do niego przypisanych
	\item Prowadziæ z nim konwersacjê tekstow¹
	\item Przegl¹daæ jego statystyki efektywnoœci.
\end{itemize}

W momencie przejœcia do widoku funkcjonalnoœci, pobierana zostaje z serwera lista wszystkich pracowników firmy. Na jej podstawie, generowana jest wartoœæ w³aœciwoœci wyliczanej, reprezentuj¹ca wszystkich u¿ytkowników za wyj¹tkiem zalogowanego pracownika. Ponadto, nastêpuje inicjacja po³¹czenia z serwerem z wykorzystaniem protoko³u WebSockets. Nastêpnie, wartoœæ wyliczana wykorzystywana jest jako zbiór danych dla listy wyboru, za pomoc¹ której u¿ytkownik okreœla, który z pracowników ma byæ nadzorowany.

Wybór pracownika z listy, determinuje przypisanie obiektu z jego danymi do wartoœci obserwowalnej, pobranie jego najnowszej pozycji lokalizacyjnej, powi¹zanych z nim dokumentów, a tak¿e statystyk efektywnoœci. Ka¿da z tych operacji, polega na wys³aniu konkretnego ¿¹dania do interfejsu API.

Po ustaleniu lokalizacji pracownika za pomoc¹ aplikacji mobilnej, wywo³ywana zostaje metoda serwera, której jedynym zadaniem jest powiadomienie wszystkich po³¹czonych klientów o wprowadzeniu do bazy danych nowego wpisu lokalizacji. Na takie zdarzenie, reaguje komponent aplikacji webowej, pobieraj¹c za pomoc¹ ¿¹dania API, najnowsz¹ lokalizacjê pracownika i wprowadzaj¹c j¹ do wartoœci obserwowalnej. Skutkuje to, aktualizacj¹ fragmentów widoku przedstawiaj¹cych adres aktualnej lokalizacji oraz ilustracjê mapy.
Na listingu \ref{lst:receive-add-location} przedstawiono omówion¹ powy¿ej metodê nas³uchuj¹c¹ na zdarzenie wprowadzenia danych lokalizacyjnych.

\begin{lstlisting}[label=lst:receive-add-location,caption=Kod akcji nas³uchuj¹cej na zdarzenie dodania lokalizacji pracownika, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
this.hub.on('ReceiveAddLocation', async () => {
	try {
		let location = await httpClient.LocationPoints.getCurrentLocationForWorker(this.selectedWorkerToInspect.id);
		if (location !== '') {
			this.inspectedWorkersLocation = location;
		}
		this.inspectedWorkersLocationLoaded = true;
		return true;
	}catch (error) {
		return false;
	}
});
\end{lstlisting}

W sposób analogiczny, opisaæ mo¿na zasadê aktualizacji danych wewn¹trz bloku przypisanych dokumentów. W tym przypadku, u¿ytkownik za pomoc¹ aplikacji mobilnej w panelu g³ównym, lub za pomoc¹ aplikacji webowej, w widoku przekazania dokumentów, wysy³a do serwera ¿¹danie wykonania metody informuj¹cej o zmianie stanu dokumentów. Metoda ta, przekazuje informacje wszystkim pozosta³ym klientom, a w ramach nas³uchuj¹cej akcji, wykonywane jest pobranie aktualnych danych zwi¹zanych z przypisanymi do pracownika dokumentami.

Fragment widoku prezentuj¹cy statystyki efektywnoœci pracownika, jest elementem, który nie jest aktualizowany z wykorzystaniem protoko³u gniazd sieciowych. Wynika to z faktu, ¿e dane przedstawiane w tym fragmencie generowane s¹ jednorazowo, po zakoñczeniu pracy przedsiêbiorstwa, przez co w momencie przejœcia do opisywanego widoku, s¹ zawsze aktualne.

Nastêpn¹ funkcjonalnoœci¹ modu³u nadzoru dostawców, jest przegl¹danie listy wpisów kilometrów. Widok tej funkcjonalnoœci ma formê tabelaryczn¹ i przedstawia wprowadzone wartoœci liczników kilometrów dla okreœlonych pojazdów, z wyszczególnieniem ich kierowcy oraz daty utworzenia wpisu.

Z chwil¹ wybrania widoku, wysy³ane jest ¿¹danie pobrania wszystkich adnotacji dotycz¹cych kilometrów pojazdów. Nastêpnie, wartoœci te nadpisuj¹, uprzedni stan w³aœciwoœci obserwowalnej \texttt{kilometers}. W³aœciwoœæ ta, zawarta wewn¹trz widoku, determinuje jego odœwie¿enie. Nastêpnie, edytowany jest fragment stanu, odpowiedzialny za wyœwietlanie widoku ³adowania treœci. Je¿eli któraœ z opisanych operacji, zakoñczy siê niepowodzeniem, u¿ytkownik jest o tym fakcie informowany poprzez komunikat w formie powiadomienia.

Na listingu \ref{lst:load-kilometers} przedstawiony zosta³ kod Ÿród³owy, akcji pobierania wpisów kilometrów dla pojazdów. 

\begin{lstlisting}[label=lst:load-kilometers,caption=Kod akcji pobieraj¹cej listê kilometrów dla pojazdów, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
@action loadKilometers = async () => {
	this.rootStore.loadingsStore.setFetchKilometersLoading(true);
	try {
		let kilometers = await httpClient.Kilometers.list();
		this.kilometers = kilometers;
		this.rootStore.loadingsStore.setFetchKilometersLoading(false);
	} catch (error) {
		toast.error('Nie uda³o siê pobraæ wpisów kilometrów');
	}
};
\end{lstlisting}

Kolejnymi funkcjonalnoœciami modu³u s¹ widoki pobierania historii lokalizacji oraz notatek handlowych. Oba z tych widoków zosta³y wykonane w sposób analogiczny, poniewa¿ przedstawiaj¹ one znacz¹co pokrewne treœci. W przypadku historii lokalizacji, pokazywane s¹ punkty lokalizacyjne dotycz¹ce pracowników, natomiast dla notatek handlowych, punkty te, rozszerzone s¹ o treœæ notatki oraz jej typ.

Po wejœciu do widoku przegl¹du historii lokalizacji, sprawdzana zostaje wartoœæ w³aœciwoœci obserwowalnej \texttt{workers}, reprezentuj¹cej listê wszystkich pracowników. Je¿eli wartoœæ ta, jest zero-elementow¹ tablic¹, oznacza to, ¿e zbiór pracowników nigdy wczeœniej nie zosta³ pobrany, wiêc nale¿y to uczyniæ w tym momencie. W przeciwnym razie, procedura uzyskiwania listy u¿ytkowników z interfejsu API jest pomijana.

Nastêpnie, u¿ytkownik wybiera jednego spoœród pracowników, dla którego chce analizowaæ historiê wpisów lokalizacji. Skutkuje to, wywo³aniem akcji magazynu, pobieraj¹cej, grupuj¹cej oraz sortuj¹cej dane adnotacji lokalizacyjnych.

Na pocz¹tku, w akcji tej, sprawdzana jest zawartoœæ zmiennej identyfikuj¹cej wybranego pracownika. Je¿eli zmienna, nie jest nieokreœlona, nastêpuje wys³anie ¿¹dania API dotycz¹cego wszystkich punktów lokalizacji pracownika. Po otrzymaniu tych punktów, s¹ one grupowane po w³aœciwoœci \texttt{date} (tj. dacie wprowadzenia), a nastêpnie sortowane wzglêdem parametru \texttt{created}. Parametr ten, poza dat¹ przechowuje tak¿e czas utworzenia wpisu lokalizacyjnego.

Przetworzone informacje s¹ nastêpnie wprowadzane do w³aœciwoœci obserwowalnej, co determinuje wyœwietlenie zbioru dat dotycz¹cych wpisów pod elementem listy wskazuj¹cym na wybranego pracownika w widoku komponentu. Modyfikowana jest tak¿e w³aœciwoœæ wskazuj¹ca na wyœwietlanie animacji ³adowania wpisów.

Niepowodzenie procedury wykonania ¿¹dania jest obs³ugiwane wewn¹trz bloku \texttt{catch} i wi¹¿e siê z wprowadzeniem do w³aœciwoœci obserwowalnej punktów lokalizacyjnych wartoœci nieokreœlonej.

Na listingu \ref{lst:load-location-points} ukazano procedurê pobrania punktów lokalizacyjnych.

\begin{lstlisting}[label=lst:load-location-points,caption=Kod akcji pobieraj¹cej listê punktów lokalizacyjnych dla pracownika, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
@action loadLocationPoints = () => {
	if (this.selectedWorker === null) {
		this.locationPoints = null;
	} else {
		this.rootStore.loadingsStore.setFetchPointsInLocationHistoryLoading(true);
		httpClient.LocationPoints.getForWorker(this.selectedWorker.id)
			.then(async (response) => {
				let grouped = await this.groupLocationPoints(response, 'date');
				let sorted = await this.sortLocationPoints(grouped, 'created');
				this.locationPoints = sorted;
				this.chosenLocationPoints = null;
				this.rootStore.loadingsStore.setFetchPointsInLocationHistoryLoading(false);
			}).catch((error) => {
				this.locationPoints = null;
			});
	}
};
\end{lstlisting}

W przypadku przedstawionej powy¿ej funkcji, nale¿y wspomnieæ o metodach grupowania oraz sortowania uzyskanych danych. W przypadku pierwszej z metod, wykorzystana zosta³a funkcja \texttt{reduce}, która na podstawie tablicy generuje pojedynczy obiekt danych. Jej pierwszym parametrem jest wywo³anie zwrotne wykonywane przy ka¿dej iteracji po tablicy, drugi parametr natomiast, to wartoœæ inicjuj¹ca docelowy obiekt. Wynik funkcji, czyli wyliczana, zgodnie z okreœlonym schematem wartoœæ, jest przypisywany do zmiennej która nastêpnie zostaje zwrócona.

Na listingu \ref{lst:group-location-points} pokazana zosta³a omówiona metoda grupowania danych.

\begin{lstlisting}[label=lst:group-location-points,caption=Kod metody grupuj¹cej uzyskane punkty lokalizacyjne, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
groupLocationPoints = async (points, by) => {
	let result = points.reduce((point, attribute) => {
		point[attribute[by]] = point[attribute[by]] || [];
		point[attribute[by]].push(attribute);
		return point;
	}, {});

	return result;
};
\end{lstlisting}

Metoda sortowania danych lokalizacyjnych, opiera siê na iteracji po grupowanym uprzednio obiekcie. Dla ka¿dego z przebiegów pêtli, w pomocniczej tablicy, zainicjowanej pocz¹tkowo tablic¹ nieposortowan¹, nadpisywane s¹ wartoœci, po wywo³aniu funkcji \texttt{sort}. Na koniec, pomocnicza tablica jest zwracana.

Funkcjê sortowania punktów lokalizacyjnych przedstawiono na listingu \ref{lst:sort-location-points}.

\begin{lstlisting}[label=lst:sort-location-points,caption=Kod metody sortuj¹cej uzyskane punkty lokalizacyjne, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
sortLocationPoints = async (points, by) => {
	let sortedLocations = points;
	for (const [keyIndex, location] of Object.entries(sortedPoints)) {
		sortedLocations[keyIndex] = location.sort((first, second) => first[by].localeCompare(second[by]));
	}

	return sortedLocations;
};
\end{lstlisting}

Po przetworzeniu danych oraz wprowadzeniu ich do zmiennej obserwowalnej, generowane s¹ dwie w³aœciwoœci wyliczane. Pierwsza z nich reprezentuje te punkty lokalizacyjne, które zosta³y uzyskane w wyniku cyklicznego pobierania lokalizacji. Druga natomiast, przedstawia punkty wygenerowane w momencie przekazania dokumentów. Wyœwietlanie konkretnego typu wpisów lokalizacji, jest uzale¿nione od zaznaczenia odpowiedniej opcji w widoku funkcjonalnoœci.

Okreœlony typ wpisów, ukazywany zostaje w komponencie mapy, jako zbiór interaktywnych znaczników. Wybranie dowolnego znacznika, powoduje pokazanie siê ma³ego okienka informacyjnego, zawieraj¹cego wszystkie dane konkretnego punktu lokalizacji.

Na listingu \ref{lst:component-map}, zilustrowano fragment widoku komponentu, odpowiedzialnego za wyœwietlanie mapy oraz znaczników lokalizacji.

\begin{lstlisting}[label=lst:component-map,caption=Kod komponentu wyœwietlaj¹cego mapê oraz znaczniki lokalizacji, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
<Map
center={[configuration.companyLatitude, configuration.companyLongitude]}>
...
{togglerValue === true ? (
{chosenLocationPointsByLocation.map(
	(point, index) => (
		<>
			<Marker icon={<Blue number={index + 1} />} position={[point.latitude, point.longitude]}>
				<Popup>
					<List size='big'>
						<List.Item>
							<List.Icon name='clock' />
							<List.Content>
								{moment(point.created).format(
									'HH:mm:ss'
								)}
							</List.Content>
						</List.Item>
						<List.Item>
							<List.Icon name='map' />
							<List.Content>
								{point.address !== null
									? point.address
									: 'Brak informacji'}
							</List.Content>
						</List.Item>
						<List.Item>
							<List.Icon name='marker' />
							<List.Content>
								{`({point.latitude}, {point.longitude})`}
							</List.Content>
						</List.Item>
						<List.Item>
							<List.Icon name='forward' />
							<List.Content>
								{point.duringForward === true
									? 'TAK'
									: 'NIE'}
							</List.Content>
						</List.Item>
					</List>
				</Popup>
			</Marker>
			...
)}
\end{lstlisting}

\subsection{Powiadamianie klientów}
W ramach funkcjonalnoœci powiadamiania klienta, u¿ytkownik wybiera dokumenty, dla których, przypisani do nich kontrahenci dostan¹ informacjê e-mailow¹, dotycz¹c¹ aktualnego statusu faktury.

W obrêbie omawianego modu³u, zdefiniowane zosta³y dwa szablony wiadomoœci e-mail. Zadaniem pierwszego z nich, jest poinformowanie klienta o przekazaniu dokumentu jednemu z pracowników wewn¹trz firmy. Wi¹¿e siê to z zaprezentowaniem kontrahentowi komunikatu "`Twoje zamówienie jest w trakcie realizacji"'. Za pomoc¹ wiadomoœci opartej na drugim z szablonów, klient zostaje zawiadomiony o niezw³ocznej wizycie dostawcy towaru.

Wiadomoœæ dotycz¹ca kroku pierwszego procedury dostarczania towaru, wysy³ana jest automatycznie do klienta w chwili pierwszego przekazania dokumentu miêdzy pracownikami. Warunkiem powiadomienia kontrahenta, jest dostêpnoœæ jego danych kontaktowych w bazie klientów.

Informacja, zwi¹zana z drugim krokiem dostawy, wys³ana mo¿e zostaæ za poœrednictwem dedykowanego widoku aplikacji webowej, lub poprzez naciœniêcie konkretnego przycisku w panelu g³ównym aplikacji mobilnej.

Do przekazywania wiadomoœci e-mail z wykorzystaniem interfejsu API, u¿yta zosta³a biblioteka MailKit. Ponadto, w zwi¹zku z relatywnie d³ugim czasem trwania wysy³ania wiadomoœci, w porównaniu do uzyskiwania odpowiedzi odnoœnie danych, metoda dostarczania e-mail jest wykonywana zgodnie z zasad¹ "`wywo³aj i zapomnij"' \textit{(ang. Fire And Forget)}. Rozwi¹zanie to, pozwala na redukcjê czasu odpowiedzi punktu koñcowego API.

Na listingu \ref{lst:service-fire-and-forget} przedstawiona zosta³a metoda generycznej klasy \texttt{FireForgetHandlerService}, odpowiedzialna za wykonanie funkcji dowolnego serwisu, zgodnie z technik¹ "`wywo³aj i zapomnij"'.

Jako parametr metoda \texttt{ExecuteffTask} przyjmuje funkcjê dowolnej klasy zwracaj¹c¹ typ \texttt{Task} (tj. funkcjê asynchroniczn¹). Wewn¹trz cia³a funkcji sk³adowej, tworzone jest nowe asynchroniczne zadanie. W zadaniu tym, wygenerowany zostaje zakres wywo³ywania serwisów \textit{(ang. scope)}. Jest to mo¿liwe, dziêki zastosowaniu instancji klasy \texttt{ServiceScopeFactory}, której abstrakcja zostaje dostarczona z wykorzystaniem mechanizmu wstrzykiwania zale¿noœci. W zwi¹zku z u¿yciem dyrektywy \texttt{using}, zakres jest usuwany od razu po zakoñczeniu bloku instrukcji. Nastêpnie, tworzona jest zmienna, przechowuj¹ca obiekt wywo³ywanego serwisu. Ostatni¹ instrukcj¹ metody, jest uruchomienie wywo³ania zwrotnego, przekazanego jako parametr, do³¹czaj¹c jako jego atrybut instancjê serwisu.

Je¿eli w trakcie którejœ z opisanych operacji wyst¹pi nieoczekiwany b³¹d, sterowanie zostanie przekazane do bloku \texttt{catch}. Skutkowa³o to bêdzie wyœwietleniem komunikatu niepowodzenia.

\begin{lstlisting}[label=lst:service-fire-and-forget,caption=Kod metody wykonuj¹cej funkcjê typu "`Fire And Forget"', captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public void ExecuteffTask(Func<T, Task> someLongRunningServiceTask) {
	Task.Run(async () => {
		try {
			using var scope = serviceScopeFactory.CreateScope();
			var service = scope.ServiceProvider.GetRequiredService<T>();
			await someLongRunningServiceTask(service);
		} catch (Exception e) {
			Console.WriteLine(e);
		}
	});
}
\end{lstlisting}

Posiadaj¹c tak przygotowan¹ metodê, mo¿liwe jest skorzystanie z niej, w kontekœcie wywo³ania serwisu wiadomoœci e-mail. Poczyniono tak wewn¹trz klasy kontrolera \texttt{EmailsController}. Na listingu \ref{lst:endpoint-email} pokazany zosta³ kod Ÿród³owy metody serwisu odpowiedzialnej za wysy³anie wiadomoœci za poœrednictwem poczty elektronicznej.

G³ównym fragmentem funkcji sk³adowej jest wykonanie omówionej w poprzednich akapitach metody \texttt{ExecuteffTask}. Metoda ta, zosta³a uruchomiona na rzecz obiektu klasy \texttt{FireForgetHandlerService}, która powi¹zana jest z klas¹ kontrolera \texttt{EmailsController} poprzez wykorzystanie mechanizmu wstrzykiwania zale¿noœci. Zasadniczym celem przedstawianej procedury, jest odwo³anie siê do funkcji \texttt{SendEmailAsync} serwisu \texttt{EmailService}.

\begin{lstlisting}[label=lst:endpoint-email,caption=Kod punktu koñcowego odpowiedzialnego za wysy³anie wiadomoœci e-mail, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public IActionResult SendAsync ([FromBody] SendClientEmailResource resource) {
	if (!ModelState.IsValid) {
		return BadRequest(ModelState.GetModelStateErrorMessagesInfo());
	}
	fireForgetHandlerService.Execute(async service => {
		var clientEmail = mapper.Map<SendClientEmailResource, ClientEmail>(resource);
		var result = await service.SendEmailAsync(clientEmail);
		if (!result.Success) Console.WriteLine(result.Message);
	});
	return NoContent();
}
\end{lstlisting}

Funkcja \texttt{SendEmailAsync}, na pocz¹tku ma za zadanie sprawdziæ istnienie okreœlonego dokumentu. Nastêpnie weryfikowane zostaj¹ dane kontaktowe przypisane do miejsca dostawy. Je¿eli dane te, s¹ nieokreœlone, wykorzystywane s¹ informacje adresowe kontrahenta.

Posiadawszy adres odbiorcy, tworzony zostaje tymczasowy obiekt klasy \texttt{Message}, przechowuj¹cy wszystkie elementy sk³adowe wiadomoœci e-mail. Kolejno, jest on przekazywany jako parametr funkcji \texttt{CreateEmailMessage}, gdzie zostaje wykorzystany przy budowie obiektu \texttt{MimeMessage}. Obiekt ten, poza atrybutami struktury pomocniczej, przechowuje zawartoœæ wys³anej wiadomoœci. Zawartoœæ, wczytana zostaje z pliku \texttt{html}, a nastêpnie w miejsce znaczników szablonu wprowadzane s¹ okreœlone wartoœci dotycz¹ce kontrahenta.

Tak przygotowany obiekt wiadomoœci, staje siê atrybutem metody \texttt{SendAsync}, odpowiadaj¹cej za realizacjê faktycznego wys³ania wiadomoœci. Na pocz¹tku tej metody, tworzona jest zmienna, przechowuj¹ca instancjê klasy \texttt{SmtpClient}. Odpowiada ona za obs³ugê ¿¹dañ w ramach klienta protoko³u poczty wychodz¹cej. Nastêpnie, inicjowane jest po³¹czenie z serwerem pocztowym. Jest ono mo¿liwe dziêki podaniu informacji uwierzytelniaj¹cych, zapisanych w konfiguracji interfejsu API. W kolejnym kroku, wysy³ana jest wiadomoœæ (tj. funkcji wysy³ania wiadomoœci przekazywany zostaje obiekt klasy \texttt{MimeMessage}). Po wys³aniu wiadomoœci, nastêpuje zakoñczenie komunikacji z serwerem oraz zwrócenie nowej instancji wiadomoœci, jako sygnalizacja poprawnoœci wykonania metody.

Na listingu \ref{lst:service-email}, zilustrowano omówion¹ powy¿ej metodê wysy³ania wiadomoœci e-mail.

\begin{lstlisting}[label=lst:service-email,caption=Kod metody serwisu odpowiedzialnej za wysy³anie wiadomoœci e-mail, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
private async Task<Response<Message>> SendAsync(MimeMessage emailMessage) {
	using var client = new SmtpClient();
	try {
		await client.ConnectAsync(emailConfiguration.SmtpServer, emailConfiguration.Port, MailKit.Security.SecureSocketOptions.StartTls);
		await client.AuthenticateAsync(emailConfiguration.UserName, emailConfiguration.Password);
		await client.SendAsync(emailMessage);
		await client.DisconnectAsync(true);
		return new Response<Message>(new Message());
	}
	catch (Exception e) {
		Console.WriteLine("Mailkit {e.Message}");
		await client.DisconnectAsync(true);
		return new Response<Message>("Wyst¹pi³ b³¹d serwera pocztowego");
	}
}
\end{lstlisting}
\subsection{Wyznaczanie trasy dostawy}
\label{sec:wyznaczanie-trasy}
Modu³ wyznaczania trasy dostawy, implementuje przedstawiony we wstêpie teoretycznym, algorytm genetyczny dla problemu komiwoja¿era. W ramach funkcjonalnoœci modu³u, u¿ytkownik, na podstawie danych z przypisanych do niego dokumentów, mo¿e wyznaczyæ trasê jak¹ powinien obraæ, aby dostarczyæ wszystkie towary powi¹zane z posiadanymi poœwiadczeniami sprzeda¿y.

Z racji specyfiki problemu, która przedstawiona zosta³a w sposób szczegó³owy w rozdziale \ref{subsec:TSPwprowadzenie}, przygotowany algorytm wyznacza trasê optymaln¹, lub w znacznym stopniu zbli¿on¹ do optymalnej. Przy za³o¿eniu dotycz¹cym mo¿liwoœci wprowadzania nieograniczonej liczby punktów trasy, uzyskanie wyniku optymalnego dla ka¿dej instancji problemu jest niemo¿liwe.

Po przejœciu do widoku opisywanej funkcjonalnoœci, u¿ytkownikowi ukazywana jest lista znalezionych punktów dostawy oraz fragment mapy. Dla ka¿dego z przypisanych do pracownika dokumentów, je¿eli w ramach faktury okreœlone zosta³y dane adresowe, znajdowane s¹ wspó³rzêdne miejsca dostawy, a nastêpnie dodawane s¹ one na mapie. W przypadku, gdy z poœwiadczeniem sprzeda¿y nie zosta³y powi¹zane jakiekolwiek dane adresu, dokument ukazywany zostaje w sekcji znalezionych punktów z adnotacj¹ o koniecznoœci wybrania dla niego lokalizacji.

Po opcjonalnym przypisaniu danych lokalizacyjnych do faktur, u¿ytkownik wybiera przycisk wywo³uj¹cy wykonanie algorytmu.

Aby uzyskaæ wynik dzia³ania algorytmu, nale¿y wys³aæ ¿¹danie do interfejsu API, który w ramach okreœlonego punktu koñcowego, wykona kod kontrolera oraz serwisu dla procedury wyliczania trasy.

W momencie uzyskania ¿¹dania dotycz¹cego wyznaczenia trasy, walidowany zostaje obiekt, w którym okreœlone s¹ punkty pokonywanej drogi. Nastêpnie, punkty te zostaj¹ odwzorowane na instancje klas modelu interfejsu API. W kolejnym kroku, wywo³ywany zostaje serwis realizuj¹cy operacjê wyliczania drogi.

W ramach serwisu, na pocz¹tku definiowane s¹ parametry konfiguracyjne algorytmu. Wœród tych parametrów mo¿emy wyró¿niæ: prawdopodobieñstwo mutacji, liczba punktów trasy, rozmiar populacji, oraz liczba osobników dominuj¹cych dla populacji potomnej. W przypadku dwóch pierwszych charakterystyk, wartoœci te s¹ sta³e. Dwie pozosta³e natomiast, zale¿ne s¹ od liczby punktów trasy i wynosz¹ kolejno: 0.75 oraz 0.25 z liczby wszystkich miejsc dostawy. Obie wartoœci zaokr¹glane s¹ w dó³ do najbli¿szych liczb naturalnych.

W kolejnym kroku, po wprowadzeniu wartoœci konfiguracyjnych, uruchamiany jest nowy w¹tek, w ramach którego przeprowadzane s¹ obliczenia. Czas trwania tych obliczeñ, zdefiniowano na 60 sekund. Okres ten, stanowi warunek zakoñczenia algorytmu.

Pocz¹tkowym krokiem procedury, jest zdefiniowanie rozwi¹zania pocz¹tkowego, bêd¹cego losowym u³o¿eniem wszystkich wprowadzonych punktów dostawy. Nastêpnie, czynnoœci wykonywane s¹ w pêtli, dla której warunkiem zakoñczenia jest flaga, modyfikowana w momencie up³ywu czasu obliczeñ.

W pierwszym kroku pêtli, aktualne rozwi¹zanie okreœlane zostaje jako najlepsze. Kolejno, wyliczana jest wartoœæ funkcji przystosowania populacji dla aktualnie najbardziej optymalnej trasy. W nastêpnym kroku, rozpoczyna siê etap ewolucji rozwi¹zañ, w ramach którego tworzona jest nowa populacja. Populacja ta, powstaje na bazie osobników dominuj¹cych z poprzedniej grupy oraz operacji selekcji, krzy¿owania, a tak¿e mutacji. Je¿eli wartoœæ funkcji przystosowania populacji potomnej jest wiêksza od wartoœci dla poprzedniej instancji, modyfikowana zostaje flaga, pozwalaj¹ca na okreœlenie rozwi¹zania, jako nowe najbardziej optymalne.

Z chwil¹ zakoñczenia pêtli, wywo³ywana jest procedura zapisuj¹ca najlepszy wynik oraz przypisuj¹ca kolejnym punktom trasy numery porz¹dkowe.

Na listingu \ref{lst:road-plan-alg-1} przedstawiona zosta³a omówiona powy¿ej metoda wyznaczania trasy dostawy dokumentów.

\begin{lstlisting}[label=lst:road-plan-alg-1,caption=Kod metody odpowiedzialnej za wyznaczenie trasy dostawy dla zbioru dokumentów, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public void Run() {
	DeliveryRoad startDeliveryRoad = new DeliveryRoad(Coordinates);
	Population population = Population.DrawPopulation(startDeliveryRoad, Config.PopulationSize);
	var improvement = true;
	_timer.Start();

	while (!Timeout)
	{
		if (improvement == true) {
			SetBestRoad(population);
		}
		
		improvement = false;
		double currentFitnessFunctionValue = population.MaximalFitnessRatio;

		population = population.PerformEvolution();
		if (currentFitnessFunctionValue < population.MaximalFitnessRatio){
			improvement = true;
		}
	}
	prepareBestRoadCoords();
}
\end{lstlisting}

Kluczowym elementem omawianej metody jest funkcja sk³adowa o nazwie \texttt{PerformEvolution}. Wewn¹trz tej funkcji, wybierane zostaj¹ osobniki dominuj¹ce z poprzedniej populacji oraz nowe osobniki zbioru potomnego. Populacja potomna stanowi z³¹czenie obu zbiorów osobników.

Kod Ÿród³owy funkcji sk³adowej \texttt{PerformEvolution} ukazany zosta³ na listingu \ref{lst:road-plan-perform-evolution}. 

\begin{lstlisting}[label=lst:road-plan-perform-evolution,caption=Kod funkcji sk³adowej wyboru populacji potomnej, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public Population PerformEvolution()
{
	var dominants = GenerateDominants(Config.NumberOfDominantsInDescendantPopulation);
	var otherDescendants = GenerateDescendantIndividuals(Config.PopulationSize - Config.NumberOfDominantsInDescendantPopulation);
	var membersOfDescendantPopulation = otherDescendants.Individuals.Concat(dominants.Individuals).ToList();
	var population = new Population(membersOfDescendantPopulation);
	return population;
}
\end{lstlisting}

Aby zrozumieæ zasadê dzia³ania funkcji z listingu \ref{lst:road-plan-perform-evolution}, nale¿y przeanalizowaæ metody \texttt{GenerateDominants} oraz \texttt{GenerateDescendantIndividuals}. Pierwsza z nich, prowadzi do wyboru osobników o najwiêkszej wartoœci funkcji dopasowania, spoœród tych, aktualnie znajduj¹cych siê w populacji.

Na pocz¹tku, tworzona jest instancja populacji na bazie aktualnie wygenerowanych osobników. Ponadto, zdefiniowana zostaje tak¿e lista rozwi¹zañ, która bêdzie stanowi³a zbiór osobników zwracanej populacji. W pêtli, wykonywanej tyle razy, ile wynosi wartoœæ okreœlona w parametrach konfiguracyjnych, wybierane s¹ najlepiej dopasowane osobniki, po czym dodawane zostaj¹ do zwracanej listy. 

Na listingu \ref{lst:road-plan-generate-dominants}, zilustrowano kod metody \texttt{GenerateDominants}.

\begin{lstlisting}[label=lst:road-plan-generate-dominants,caption=Kod metody generuj¹cej zbiór osobników dominuj¹cych dla nowej populacji, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public Population GenerateDominants(int count) {
	var population = new Population(Individuals);
	var dominants = new List<DeliveryRoad>();
	var i = 0;
	while (i < count)
	{
			dominants.Add(population.GetBestIndividual());
			var modifiedIndividuals = population.Individuals.Except(dominants).ToList();
			population = new Population(modifiedIndividuals);
			i++;
	}
	var dominativePopulation = new Population(dominants);
	return dominativePopulation;
}
\end{lstlisting}

Metoda \texttt{GenerateDescendantIndividuals} z kolei, utworzona zosta³a w celu wygenerowania pozosta³ych osobników populacji potomnej, za pomoc¹ operacji selekcji, krzy¿owania oraz mutacji. Operacje te, wykonywane s¹ w pêtli, tyle razy, ilu osobników nale¿y wygenerowaæ do nowej populacji. Po przeprowadzeniu procesów algorytmu genetycznego, jednostki dodawane s¹ do zwracanego zbioru.

W ramach listingu \ref{lst:road-plan-generate-others}, przedstawiono kod Ÿród³owy metody generowania pozosta³ych osobników populacji.

\begin{lstlisting}[label=lst:road-plan-generate-others,caption=Kod metody generuj¹cej zbiór pozosta³ych osobników dla nowej populacji, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public Population GenerateDescendantIndividuals(int count) {
	var individuals = new List<DeliveryRoad>();
	var i = 0;
	while (i < count)
	{
		var delivery = PerformSelection();
		delivery = delivery.PerformCrossing(PerformSelection());

		for (var j = 0; j < delivery.Vertices.Count; i++) {
				delivery = delivery.PerformMutation();
		}
		
		individuals.Add(delivery);
		i++;
	}

	var population = new Population(individuals);
	return population;
}
\end{lstlisting}

Podstawowymi elementami sk³adowymi ka¿dego algorytmu genetycznego s¹ operacje: selekcji, krzy¿owania oraz mutacji. Poni¿ej, ka¿da z nich zostanie szczegó³owo omówiona.

W odniesieniu do procedury selekcji osobników, pierwszym krokiem tej operacji wygenerowanie losowej wartoœci stanowi¹cej indeks osobnika z populacji. Nastêpnie, wyliczany jest u³amek, okreœlaj¹cy szanse osobnika, na dostanie siê do populacji potomnej. Szansa ta, to iloraz wartoœci funkcji przystosowania osobnika przez maksymaln¹ wartoœæ przystosowania populacji.

Je¿eli szansa osobnika, jest wiêksza od losowo wygenerowanej liczby z przedzia³u <0,1>, wówczas osobnik trafia do populacji potomnej.

Opisana metoda selekcji, nazywana metod¹ ruletkow¹, ukazana zosta³a na listingu \ref{lst:road-plan-generate-others}.

\begin{lstlisting}[label=lst:road-plan-generate-others,caption=Kod metody generuj¹cej zbiór pozosta³ych osobników dla nowej populacji, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public DeliveryRoad PerformSelection() {
	for (;;) {
		var index = Generator.Next(0, Config.PopulationSize);
		double percentOfChances = Individuals[index].FitnessRatio / MaximalFitnessRatio;
		if (percentOfChances > Generator.NextDouble()) {
				var vertices = Individuals[index].Vertices;
				return new DeliveryRoad(vertices);
		}
	}
}
\end{lstlisting}

Drugim z elementów algorytmu genetycznego jest operacja krzy¿owania. W procedurze tej, losowane s¹ dwie zmienne z zakresu licznoœci punktów dostaw. Pierwsza z nich, posiada zawsze mniejsz¹ wartoœæ od drugiej, poniewa¿ losowanie kolejnej z nich odbywa siê w zakresie rozpoczynaj¹cym siê od wartoœci liczby ju¿ wylosowanej.

Nastêpnie wykonywana jest zamiana fragmentów list wierzcho³ków (punktów dostaw), w obrêbie dwóch ró¿nych osobników. Z jednego osobnika, pobierany jest fragment ograniczony przez zdefiniowane uprzednio liczby, natomiast drugi osobnik dostarcza pozosta³e z fragmentów trasy.

Przedstawiona procedura krzy¿owania, opisywana jest jako krzy¿owanie dwupunktowe. Treœæ omówionego kodu Ÿród³owego dla operacji krzy¿owania zaprezentowana zosta³a na listingu \ref{lst:road-plan-generate-others}.

\begin{lstlisting}[label=lst:road-plan-generate-others,caption=Kod metody generuj¹cej zbiór pozosta³ych osobników dla nowej populacji, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public DeliveryRoad PerformCrossing(DeliveryRoad road) {
	var firstPoint = Generator.Next(0, road.Vertices.Count);
	var secondPoint = Generator.Next(firstPoint, road.Vertices.Count);
	DeliveryRoad delivery = null;
	
	var firstsIndividualPiece = Vertices.GetRange(firstPoint, secondPoint-firstPoint+1);
	var secondsIndividualPiece = road.Vertices.Except(firstsIndividualPiece).ToList();
	var crossed = secondsIndividualPiece.Take(firstPoint).Concat(firstsIndividualPiece).Concat(secondsIndividualPiece.Skip(firstPoint)).ToList();
	
	delivery = new DeliveryRoad(crossed);
	return delivery;
}
\end{lstlisting}

Ostatni¹ operacj¹ kluczow¹ dla algorytmu genetycznego jest mutacja osobnika. W ramach tej operacji, pocz¹tkowo wyliczana jest losowa wartoœæ z przedzia³u [ 0,1 ], determinuj¹ca prawdopodobieñstwo zajœcia zdarzenia mutacji. Kolejno, porównana zostaje wylosowana wartoœæ z dan¹ konfiguracyjn¹ prawdopodobieñstwa mutacji. Je¿eli wartoœæ danej konfiguracyjnej jest wiêksza od wygenerowanej losowo liczby, omawiana operacja zachodzi.

Nastêpnym krokiem jest wyznaczenie dwóch punktów dostaw, stanowi¹cych wierzcho³ki trasy, w celu zamiany ich kolejnoœci. Zmodyfikowana trasa, reprezentuj¹ca pojedynczego osobnika, zostaje na koñcu zwrócona do funkcji wywo³uj¹cej.

Na listingu \ref{lst:road-plan-mutation}, zilustrowano kod Ÿród³owy metody wykonuj¹cej operacjê mutacji.

\begin{lstlisting}[label=lst:road-plan-mutation,caption=Kod funkcji sk³adowej wykonuj¹cej operacjê mutacji osobnika, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public DeliveryRoad PerformMutation() {
	var coordinates = new List<Vertex>(Vertices);
	var probability = Generator.NextDouble();
	DeliveryRoad delivery = null;

	if (Config.MutationProbability > probability) {
		var swappedIndexOne = Generator.Next(0, Vertices.Count);
		var swappedIndexTwo = Generator.Next(0, Vertices.Count);

		var temp = coordinates[swappedIndexOne];
		coordinates[swappedIndexOne] = coordinates[swappedIndexTwo];
		coordinates[swappedIndexTwo] = temp;
	}

	delivery = new DeliveryRoad(coordinates);
	return delivery;
}
\end{lstlisting}

\subsection{Zarz¹dzanie systemem}
Modu³ zarz¹dzania systemem zawiera w sobie funkcjonalnoœci, pozwalaj¹ce na modyfikacjê zbioru danych, dotycz¹cego kluczowych aspektów przedstawianego oprogramowania. Wyró¿niæ mo¿emy w nim: edycjê danych konfiguracyjnych, usuwanie b³êdnie wprowadzonych dokumentów, zarz¹dzanie wyjaœnieniami, administracjê danych pracowników, aktualizacjê informacji o pojazdach, przyznawanie oraz odbieranie uprawnieñ, a tak¿e przegl¹d statystyk.

W ramach pierwszej funkcjonalnoœci, u¿ytkownik mo¿e okreœliæ dane adresowe i lokalizacyjne firmy. Informacje te, potrzebne s¹ do prawid³owego dzia³ania modu³u wyznaczania trasy dostawy oraz nadzorowania wewnêtrznych dostawców. Pe³ni¹ one rolê punktu startowego, dla opisanego w podrozdziale \ref{sec:wyznaczanie-trasy} algorytmu komiwoja¿era, a tak¿e pozwalaj¹ okreœliæ pozycjê pracownika na mapie, w sytuacji, gdy nie zosta³ wprowadzony jakikolwiek wpis lokalizacji urz¹dzenia mobilnego.

Dodatkowo, w obszarze formularza danych konfiguracyjnych, znajduj¹ siê informacje odnoœnie czasu trwania: procedury skanowania dokumentów, przechowywania wpisów w historii lokalizacji, gromadzenia dziennych statystyk kierowców, czy te¿ magazynowania adnotacji archiwalnych dotycz¹cych faktur. Wartoœci te, wykorzystywane s¹ przez skrypty archiwizuj¹ce, w celu okreœlenia zakresu danych, które maj¹ zostaæ usuniête, wraz z zakoñczeniem dnia pracy przedsiêbiorstwa.

Ponadto, formularz zawiera prze³¹cznik, determinuj¹cy domyœlny tryb skanowania dokumentów. Je¿eli znajduje siê on w pozycji w³¹czonej, w funkcjonalnoœciach skanowania uruchomione zostaj¹ komponenty odpowiedzialne za u¿ycie rêcznego skanera kodów QR. W przeciwnym razie, wyœwietlanym komponentem, jest fragment interfejsu pozwalaj¹cy na wykorzystanie kamery internetowej.

Wszystkie z wymienionych opcji konfiguracyjnych, przechowywane s¹ w bazie danych w formie rekordu jednowierszowej tabeli.

Nastêpn¹ funkcjonalnoœci¹ modu³u jest usuwanie dokumentów. Narzêdzie to, zosta³o stworzone, aby zapobiegaæ sytuacji omy³kowego wprowadzenia do systemu niepo¿¹danej faktury. W ramach aplikacji webowej, przygotowany zosta³ widok tabelaryczny, w którym, przy ka¿dym z dokumentów znajduje siê przycisk jego usuniêcia. Naciœniêcie przycisku, powoduje wywo³anie ¿¹dania usuniêcia dowodu sprzeda¿y poprzez interfejs API. W zwi¹zku z ustawionymi wymogami, dotycz¹cymi modyfikacji danych w bazie \textit{(ang. constraints)}, w momencie usuniêcia dokumentu, w sposób kaskadowy skasowane zostaj¹ informacje o jego przekazaniach, a tak¿e wszystkie przypisane do niego uwagi i wyjaœnienia. Rekomendowanym jest, przypisanie uprawnienia do tej funkcjonalnoœci, tylko i wy³¹cznie u¿ytkownikowi sprawuj¹cemu rolê administratora systemu, który móg³by z niej skorzystaæ tylko w szczególnych przypadkach.

Trzeci¹ funkcjonalnoœci¹ segmentu zarz¹dzania systemem jest kontrola wyjaœnieñ. W ramach tej czêœci aplikacji, u¿ytkownikowi przedstawiany jest widok, w którym w kolejnych wierszach tabeli ukazane zostaj¹ informacje, dotycz¹ce utworzonych wyjaœnieñ dokumentów. Pracownik mo¿e analizowaæ przedstawione wyjaœnienia, a tak¿e, po naciœniêciu okreœlonego przycisku, uniewa¿niaæ je.

Uniewa¿nienie wyjaœnienia dokumentu wi¹¿e siê z jego usuniêciem z bazy danych, co skutkuje pozostaniem poœwiadczenia sprzeda¿y "`w obiegu"', na kolejne dni pracownicze.

Kolejnymi funkcjonalnoœciami s¹ widoki s³u¿¹ce do modyfikacji danych pracowników oraz pojazdów. W ich kontekœcie, przedstawiæ mo¿emy podstawowe operacje na zbiorach danych, takie jak dodawanie, usuwanie czy modyfikacja informacji o pracownikach, a tak¿e samochodach, dostêpnych w obrêbie oddzia³u firmy. Oba widoki oparte s¹ o tabele przedstawiaj¹ce zbiory danych, a tak¿e formularze w oknach modalnych, wykorzystywane do wprowadzania oraz edycji elementów zbiorów.

Poza przedstawionymi funkcjonalnoœciami wyró¿niæ mo¿emy tak¿e, segment przyznawania uprawnieñ pracownikom. W segmencie tym, u¿ytkownik wybiera pracownika, spoœród listy wszystkich dostêpnych, a nastêpnie, z wykorzystaniem listy prze³¹czników, definiuje do których fragmentów aplikacji pracownik powinien mieæ dostêp.

Operacje przyznawania oraz odbierania uprawnieñ pracowniczych, sprowadzaj¹ siê do wysy³ania ¿¹dañ dodania lub usuniêcia wpisu za pomoc¹ interfejsu API.

Ostatni¹ funkcjonalnoœci¹ modu³u zarz¹dzania systemem jest przegl¹d statystyk. W ramach tego fragmentu aplikacji, u¿ytkownikowi pokazywane s¹ cztery rodzaje wykresów, opisuj¹cych efektywnoœæ pracowników oraz zu¿ycie pojazdów. W zwi¹zku z wiêkszym stopniem zaawansowania operacji, dotycz¹cych dostarczania danych dla wykresów, w przeciwieñstwie do dzia³añ wykonywanych w ramach poprzednich funkcjonalnoœci, przedstawiony zostanie opis przytaczanej operacji oraz kody Ÿród³owe dla konkretnych jej elementów.

Po uruchomieniu widoku przegl¹dania statystyk, aplikacja webowa wysy³a do interfejsu API cztery niezale¿ne ¿¹dania, dotycz¹ce danych dla wykresów. ¯¹dania te, obs³ugiwane s¹ przez metody punktów koñcowych, zgodnie ze schematem wprowadzonym w podrozdziale \ref{sec:api-implementacja}.

Momentem faktycznego uzyskiwania danych dla wykresów, jest wywo³anie metody klasy repozytorium. Jedna z takich metod, tj. funkcja sk³adowa uzyskiwania kilometrów wykonanych przez pracowników, przedstawiona zosta³a na listingu \ref{lst:worker-stat}.

Na pocz¹tku funkcji, pobierana zostaje lista wszystkich pracowników oddzia³u przedsiêbiorstwa. Nastêpnie, tworzony jest pomocniczy obiekt, który na koñcu metody zostanie zwrócony jako rozwi¹zanie.

Dla ka¿dego z pracowników, uzyskiwane s¹ wpisy kilometrów ich autorstwa, wykonane w przedziale czasowym okreœlonym przez obiekt \texttt{DateRange}, bêd¹cy parametrem funkcji sk³adowej. Dla opisywanego ¿¹dania, tj. wykonywanego w momencie uruchomienia widoku, obiekt zakresu dat posiada takie wartoœci, które nie ograniczaj¹ wyboru wpisów.

Je¿eli uzyskany zbiór adnotacji kilometrowych nie jest pusty, tworzony zostaje obiekt statystyki dla pojedynczego u¿ytkownika. Nastêpnie, zdefiniowany jest licznik, przechowuj¹cy liczbê wykonanych przez przez pracownika kilometrów. Iteruj¹c po ka¿dej z adnotacji, znajdowana zostaje liczba kilometrów, przypisana do pojazdu uwzglêdnionego w adnotacji, z dat¹ z przed wprowadzenia wpisu. Je¿eli taka liczba istnieje, nale¿y j¹ dodaæ do sumy kilometrów pracownika, w przeciwnym razie, suma kilometrów uzupe³niana jest wartoœci¹ z wpisu u¿ytkownika.

Po wykonaniu obliczeñ w ramach pêtli adnotacji kilometrowych, do obiektu statystyki pracownika dopisywana jest wyznaczona liczba kilometrów, a do zwracanej listy, obiekt statystyki.

Z chwil¹ zakoñczenia pêtli iteruj¹cej po zbiorze pracowników, zwracana jest skonstruowana lista.

\begin{lstlisting}[label=lst:worker-stat,caption=Kod metody repozytorium przygotowuj¹cej dane dla wykresu kilometrów, captionpos=b,basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={[Sharp]C}]
public async Task<IList<WorkerStat>> GetKilometersForWorkersStatsAsync(DateRange dateRange) {
	var workers = await context.Workers.ToListAsync();
	var stats = new List<WorkerStat>();

	foreach (var worker in workers) {
		var workersOdometers = await context.VehicleOdometers
				.Include(w => w.Worker)
				.Include(w => w.Vehicle)
				.Where(w => w.WorkerId == worker.Id && w.Date.Date.CompareTo(dateRange.FromDate.Date) >= 0 && w.Date.Date.CompareTo(dateRange.ToDate.Date) <= 0)
				.ToListAsync();

			if (workersOdometers != null) {
				var workerStat = new WorkerStat {
						WorkerId = worker.Id,
						WorkerFirstName = worker.FirstName,
						WorkerLastName = worker.LastName,
				};

				var kilometers = 0.0;
			
				foreach (var odometers in workersOdometers) {
						var previousKilometers = await context.VehicleOdometers
								.Where(x => x.VehicleId == odometers.VehicleId && x.Date.CompareTo(odometers.Date) < 0)
								.OrderByDescending(x => x.Date).ToListAsync();

						if (previousKilometers.Count > 0) {
							var previous = previousKilometers.First();
							kilometers += (odometers.Value - previous.Value);
						}
						else {
							kilometers += odometers.Value;
						}
					}
					workerStat.Kilometers = kilometers;
					stats.Add(workerStat);
			}
	}
	return stats;
}
\end{lstlisting}

Po zilustrowaniu w widoku wszystkich wykresów, u¿ytkownik mo¿e wprowadzaæ do znajduj¹cych siê nad nimi formularzy, okreœlone zakresy dat. Czynnoœæ ta, skutkuje ponowieniem ¿¹dania uzyskania danych od interfejsu API. W tym przypadku jednak, widoczne na listingu \ref{lst:worker-stat} kalkulacje, uwzglêdniaæ bêd¹ dok³adny przedzia³ czasowy.
\section{Aplikacja mobilna}
\subsection{Panel g³ówny u¿ytkownika}
Panel g³ówny u¿ytkownika jest podstawowym widokiem utworzonym w ramach aplikacji mobilnej. Wyró¿niæ mo¿emy w nim trzy zak³adki, prezentuj¹ce odpowiednio: dokumenty dostarczone przez pracownika, dokumenty dla których pracownik zg³osi³ uwagê oraz pozosta³e faktury. W obszarze ka¿dej zak³adki, wyœwietlana jest lista dokumentów, wraz ze zdefiniowanymi dla nich akcjami.

Dla ka¿dego z dokumentów wykonaæ mo¿na nastêpuj¹ce operacje:
\begin{itemize}
	\item Przekazanie klientowi
	\item Uruchomienie nawigacji do klienta
	\item Przekazanie innemu pracownikowi
	\item Poinformowanie klienta o zbli¿aj¹cej siê dostawie
	\item Zg³oszenie uwagi.
\end{itemize}

Operacje przekazania faktur do klienta lub pracownika, zaimplementowane zosta³y w sposób analogiczny do aplikacji webowej. Po naciœniêciu okreœlonego przycisku, aplikacja wysy³a ¿¹danie do interfejsu API, dostarczaj¹c jako zasób obiekt przekazania, zawieraj¹cy miêdzy innymi nadawcê, odbiorcê oraz transferowany dokument. Po otrzymaniu poprawnej odpowiedzi na wys³ane ¿¹danie, aplikacja wywo³uje metodê odœwie¿enia listy dokumentów.

Funkcja uruchomienia nawigacji do klienta, w pocz¹tkowej fazie weryfikuje obecnoœæ danych adresowych, dotycz¹cych miejsca dostawy oraz kontrahenta. Je¿eli informacje o miejscu dostawy s¹ przypisane do klienta, wywo³ywana jest metoda \texttt{navigate} klasy \texttt{LaunchNavigator}. Parametrem tej metody, jest wynik zwrócony z funkcji, przygotowuj¹cej ci¹g tekstowy na podstawie danych adresowych.

W przypadku braku informacji dotycz¹cych adresu miejsca dostawy, weryfikowane s¹ dane adresowe kontrahenta. W sytuacji pomyœlnej identyfikacji tych danych, aplikacja wyœwietla komunikat, w ramach którego, u¿ytkownik musi zdecydowaæ, czy chce byæ kierowany pod adres klienta, czy te¿ procedura ma siê zakoñczyæ.

Je¿eli u¿ytkownik zaakceptuje wyœwietlony komunikat, wykonywana jest analogiczna czynnoœæ do opisanej powy¿ej dla miejsca dostawy.

Modu³ informowania klienta o zbli¿aj¹cej siê dostawie, zosta³ zaimplementowany analogicznie do funkcjonalnoœci powiadamiania kontrahentów w aplikacji webowej. Po wybraniu przycisku informowania, wykonywany jest kod punktu koñcowego API, odpowiedzialnego za wysy³anie wiadomoœci e-mail. Na podstawie dostarczonego do API obiektu zasobu ¿¹dania, podczas wys³ania wiadomoœci wybierany zostaje szablon, w treœci którego widnieje informacja o niezw³ocznej wizycie pracownika. Nadanie wiadomoœci, determinowane jest obecnoœci¹ w bazie danych, informacji kontaktowych dla miejsca dostawy. W przypadku braku tych informacji sprawdzane s¹ dane kontaktowe kontrahenta. 

Funkcjonalnoœæ zg³oszenia uwagi, pozwala pracownikowi poradziæ sobie w sytuacji, w której dla danego dokumentu, lista zabranych przez niego z magazynu produktów jest niekompletna. Je¿eli u¿ytkownik zauwa¿y tak¹ ewentualnoœæ podczas dostawy towaru, musi utworzyæ notatkê uwagi. Po naciœniêciu przycisku uwagi dla konkretnego dokumentu, wyœwietlane jest pole tekstowe, wewn¹trz którego nale¿y wprowadziæ treœæ informacji. Po zatwierdzeniu wpisanego tekstu, notatka uwagi zapisywana jest do bazy danych poprzez interfejs API.

Zapis notatki, determinuje aktualizacjê widoków œledzenia dokumentów dla wszystkich klientów aplikacji webowych. Dziêki temu, pracownik stacjonarny oddzia³u firmy, na bie¿¹co dowiaduje siê o zg³oszonych uwagach.  

\subsection{Wprowadzanie wpisów kilometrów}
\label{subsec:mobilna-kilometry}
Widok wprowadzania wpisów kilometrów, pozwala u¿ytkownikowi okreœliæ stan licznika kilometrów, dla pojazdu, z wykorzystaniem którego dostarcza³ towar. Przedstawiana aktywnoœæ zawiera formularz, w ramach którego wyró¿niæ mo¿emy cztery pola.

Pierwsze z nich, to lista rozwijana, z której pracownik wybiera samochód. Z chwil¹ uruchomienia widoku, pobierana zostaje lista wszystkich pojazdów, a tak¿e, je¿eli jest taka koniecznoœæ, zbiór pracowników. Je¿eli do pracownika, przypisany jest pojazd domyœlny, zostanie on wyœwietlony jako pierwszy w liœcie rozwijanej.

Kolejne pola okreœlaj¹ pracownika oraz datê wprowadzenia wpisu. Pole te s¹ wype³niane automatycznie, a u¿ytkownik nie mo¿e zmieniæ ich zawartoœci.

Ostatnim fragmentem formularza jest pole tekstowe pozwalaj¹ce na wprowadzenie liczby kilometrów. W momencie, w którym pole to, zostanie wype³nione, a tak¿e wybrany jest pojazd, przycisk zatwierdzenia staje siê aktywny i mo¿e zostaæ wys³ane ¿¹danie zapisu adnotacji do bazy danych.

Dane, wprowadzane przez u¿ytkownika, podobnie jak w pozosta³ych formularzach w obrêbie aplikacji mobilnej, przechowywane s¹ z wykorzystaniem stanu wewnêtrznego komponentu aplikacji. W przypadku operacji dodania wpisu, odwo³uje siê ona natomiast, do klasy magazynu, wp³ywaj¹cej na stan zewnêtrzny.

\subsection{Wprowadzanie notatek handlowych}
Aktywnoœæ wprowadzania notatek, pozwala pracownikom handlowym, na definiowanie adnotacji dotycz¹cych wykonywanych przez nich odwiedzin klientów. W ramach widoku, wyszczególnionych jest piêæ pól formularza, okreœlaj¹cych: pracownika, aktualny czas, lokalizacjê, typ oraz treœæ notatki.

Po uruchomieniu aktywnoœci, pobierana jest lista pracowników, dostêpne typy notatek oraz aktualna lokalizacja telefonu (informacje dotycz¹ce sposobu pozyskiwania lokalizacji telefonu u¿ytkownika opisane zosta³y w rozdziale \ref{sec:cykliczna-lokalizacja}). Informacje te, poza lokalizacj¹, uzyskiwane s¹ poprzez odpowiedŸ na ¿¹danie interfejsu programowania aplikacji, tylko wtedy, gdy nie zosta³y one wczeœniej pozyskane przez inny widok aplikacji.

Formularz wprowadzania notatek, podobnie jak opisywany w rozdziale \ref{subsec:mobilna-kilometry} formularz wprowadzania kilometrów, wykonany zosta³ z wykorzystaniem techniki komponentów kontrolowanych. Oznacza to, ¿e dla ka¿dego z wype³nianych pól ankiety, zdefiniowany zosta³ wewnêtrzny element stanu przechowuj¹cy jego zawartoœæ. W momencie zdarzenia, zmiany wartoœci pola, wywo³ywana jest metoda aktualizacji elementu stanu. Dziêki wykorzystaniu tej metody, wartoœci pól formularza dostêpne s¹ dla funkcji zapisuj¹cej ankietê, w sposób nie wymagaj¹cy tworzenia obiektów referencji.
\subsection{Cykliczna lokalizacja urz¹dzenia}
\label{sec:cykliczna-lokalizacja}
Kluczow¹ funkcjonalnoœci¹, wykorzystywan¹ w wielu widokach aplikacji mobilnej jest lokalizowanie telefonu u¿ytkownika. Modu³ ten, wykonany zosta³, zarówno poprzez zdefiniowanie odpowiednich komponentów i us³ug za pomoc¹ biblioteki React-Native, jak i poprzez napisanie kodu natywnego w jêzyku Java dla systemu Android.

Lokalizacja u¿ytkownika, odbywa siê poprzez cykliczne wywo³ania funkcji, wewn¹trz aplikacji komponentów stworzonych w React-Native. Aby funkcja ta, mog³a byæ wywo³ywana, niezale¿nie od renderowanego widoku aplikacji (tj. dzia³aæ w tle), musi zostaæ zdefiniowana jako osobne zadanie \textit{(tzw. Headless Task)}.

Poprawne zarejestrowanie osobnego zadania, wymaga dokonania zmian w kodzie natywnym aplikacji. Zmiany te, polegaj¹ na utworzeniu nowej klasy dziedzicz¹cej po serwisie \texttt{HeadlessJsTaskService}. Klasa ta, w metodzie \texttt{getTaskConfig}, ma za zadanie pobraæ informacje dodatkowe, dotycz¹ce przekazywanej jako argument intencji. Intencja natomiast, stanowi obiekt umo¿liwiaj¹cy po³¹czenie ze sob¹ aktywnoœci w ramach aplikacji. Je¿eli obiekt intencji, posiada dodatkowe informacje, to s¹ one wykorzystywane jako parametr wywo³ania konstruktora obiektu zwracanej klasy \texttt{HeadlessJsTaskConfig}. Ponadto, pozosta³ymi parametrami s¹: nazwa tworzonego zadania, wartoœæ ograniczenia czasowego dla zadania, a tak¿e mo¿liwoœæ wykonywania dzia³ania z koniecznoœci¹ poinformowania o tym fakcie u¿ytkownika. Opisany kod metody, z klasy dziedzicz¹cej po klasie serwisu \texttt{HeadlessJsTaskService}, przedstawiony zosta³ na listingu \ref{lst:headless-task-config}.

\begin{lstlisting}[label=lst:headless-task-config,caption=Kod metody pozwalaj¹cej na zarejestrowanie osobnego zadania, captionpos=b, basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={Java}]
protected HeadlessJsTaskConfig getTaskConfig(Intent passedIntent) {
	Bundle intentsExtras = passedIntent.getExtras();
	return new HeadlessJsTaskConfig("Notification", intentsExtras != null ? Arguments.fromBundle(intentsExtras) : Arguments.createMap(),0,true);
}
\end{lstlisting}

Aby kod funkcji, zdefiniowanej z obszarze aplikacji React, wykonywany by³ cyklicznie, zdefiniowany musi zostaæ nowy w¹tek, dla klasy serwisu powiadomieñ, wywo³uj¹cy zadanie, co okreœlony przedzia³ czasu. W¹tek ten, rozpoczyna swoje dzia³anie z chwil¹ wywo³ania metody \texttt{startService} dla obiektu klasy serwisu.

W ramach w¹tku (tj. obiektu klasy Runnable), uruchamiana zostaje metoda \texttt{run}. W metodzie tej, na pocz¹tku pobierany jest kontekst aplikacji. Dziêki niemu, mo¿liwe jest utworzenie nowej intencji (obiektu klasy \texttt{Intent}), która wi¹¿e stan aplikacji w obecnym momencie jej dzia³ania z obiektem klasy osobnych zadañ, opisanym w powy¿szych akapitach. Posiadaj¹c takie po³¹czenie, wywo³ywana zostaje metoda uruchomienia serwisu, której parametrem jest utworzona intencja. Nastêpnie, wykorzystywana zostaje funkcja \texttt{acquireWakeLockNow}, której celem jest sprawienie, aby urz¹dzenie nie przesz³o w stan uœpienia, przed rozpoczêciem zadania.
Ostatnim elementem w¹tku, jest wywo³anie ca³ej metody \texttt{run} ponownie, po up³ywie piêtnastu minut (tj. 300000ms). Omówiona funkcja ukazana zosta³a na listingu \ref{lst:runnable-task}.

\begin{lstlisting}[label=lst:runnable-task,caption=Kod w¹tku wykonuj¹cego zadanie lokalizacji z interwa³em czasowym, captionpos=b, basicstyle=\footnotesize\ttfamily,style=sharpcstyle,language={Java}]
private Runnable runnableLocationCode = new Runnable() {
	@Override
	public void run() {
		Context mainAppContext = getApplicationContext();
		Intent intentToHeadlessTask = new Intent(mainAppContext, HeadlessTaskConfig.class);
		mainAppContext.startService(intentToHeadlessTask);
		HeadlessJsTaskService.acquireWakeLockNow(mainAppContext);
		handler.postDelayed(this, 300000);
	}
};
\end{lstlisting}

Po zdefiniowaniu kodu dla warstwy natywnej aplikacji mobilnej, przygotowany zosta³ kod zadania, wykonywanego wewn¹trz warstwy aplikacji React-Native. W ramach tego kodu, weryfikowane jest istnienie zalogowanego u¿ytkownika. Je¿eli weryfikacja ta, przebiega pomyœlnie, wywo³ywana zostaje statyczna metoda, której zadaniem jest uzyskanie lokalizacji oraz zapisanie pozycji pracownika w bazie danych.

Wewn¹trz metody lokalizuj¹cej, na pocz¹tku wykonywane jest ¿¹danie uprawnieñ od u¿ytkownika. Je¿eli pracownik zezwoli na udostêpnienia do lokalizacji, wykonywana zostaje faktyczna procedura pozyskiwania danych geolokalizacyjnych.

W ramach tej procedury, wykorzystywana jest metoda \texttt{getCurrentPosition} klasy \texttt{Geolocation}, bêd¹ca elementem wbudowanym pakietu dostarczanego przez twórców React-Native. Wewn¹trz wywo³ania zwrotnego, wykonywanego w momencie uzyskania danych, punkty geograficzne zapisywane s¹ do atrybutów obiektu w³asnej klasy, a nastêpnie wysy³ane poprzez ¿¹danie do interfejsu API. W przypadku b³êdu podczas uzyskiwania lokalizacji, wywo³ywana zostaje metoda analogiczna do \texttt{getCurrentPosition}, lecz z parametrem \texttt{enableHighAccuracy} posiadaj¹cym wartoœæ false. Parametr ten, determinuje dok³adnoœæ lokalizacji, poprzez wykorzystanie konkretnych metod lokalizuj¹cych. Na listingu \ref{lst:get-current-position}, zilustrowano opisany w niniejszym akapicie kod Ÿród³owy procedury lokalizacji.

\begin{lstlisting}[label=lst:get-current-position,caption=Kod metody uzyskuj¹cej lokalizacjê urz¹dzenia u¿ytkownika, captionpos=b,basicstyle=\footnotesize\ttfamily,language=JavaScript]
getLocation = async (user) => {
    Geolocation.getCurrentPosition(
      async (position) => {
        this.currentLocation.latitude = Number(
          position.coords.latitude,
        ).toFixed(7);
        this.currentLocation.longitude = Number(
          position.coords.longitude,
        ).toFixed(7);
        await this.upload(user);
      },
      (error) => {
        this.getLocationWithoutHighAccuracy(user);
      },
      {enableHighAccuracy: true, timeout: 5000},
    );
  };
\end{lstlisting}

\section{Skrypty archiwizuj¹ce}
W celu usuwania zbêdnych informacji, oraz archiwizacji dokumentów nie bêd¹cych ju¿ w obiegu pracowniczym, utworzone zosta³y skrypty porz¹dkuj¹ce dane systemu. Skrypty te, mog¹ byæ wywo³ywane cyklicznie, o okreœlonych porach dnia, poprzez dodanie ich jako zadania, w narzêdziach takich jak np. aplikacja \texttt{cron}.

G³ównym zadaniem skryptu jest kontrolowanie czasu od poprzedniego wykonania, a w okreœlonym momencie, zdefiniowanie ¿¹dania do interfejsu API, oraz odebranie jego odpowiedzi.

Utworzone w ramach systemu skrypty dotycz¹: przechowywania wpisów historii lokalizacji, gromadzenia dziennych statystyk, zachowywania dokumentów w archiwum, a tak¿e przenoszenia faktur koñcz¹cych obieg pracowniczy, do zbioru archiwalnego.

W obecnym rozdziale, przedstawiona zostanie implementacja programu, kontroluj¹cego proces przechowywania wpisów historii lokalizacji.

Na pocz¹tku, wykonywane jest ¿¹danie logowania, w celu uzyskania tokenu autoryzuj¹cego. Danymi tego ¿¹dania, s¹ login oraz has³o dedykowanego do wykonywania skryptów u¿ytkownika systemu. Po poprawnym uwierzytelnieniu, pobierany z serwera jest rekord, okreœlaj¹cy konfiguracjê oprogramowania. Na podstawie jego danych, bêdzie mo¿na zweryfikowaæ koniecznoœæ wykonywania operacji archiwizacji. Po uzyskaniu danych konfiguracji, wyliczana jest ró¿nica dni pomiêdzy aktualn¹ dat¹ a momentem ostatniej modyfikacji parametru przechowywania wpisów lokalizacyjnych. Je¿eli ró¿nica ta, jest wiêksza od zera, a ponadto reszta z jej dzielenia przez liczbê przechowywan¹ w konfiguracji jest równa zero, nale¿y wywo³aæ punkt koñcowy, archiwizuj¹cy wpisy lokalizacyjne z konkretnej liczby ostatnich dni. W momencie niepowodzenia, jakiejkolwiek z opisywanych operacji, lub zwrócenia nieoczekiwanego kodu odpowiedzi na ¿¹danie, informacja ta jest odnotowywana w dzienniku logów systemu operacyjnego. 

Omówiony fragment skryptu archiwizuj¹cego zilustrowany zosta³ na listingu \ref{lst:skrypt-historia-lokalizacji}.

\section{Interfejs u¿ytkownika}
W niniejszym rozdziale, przedstawiono widoki gotowego interfejsu u¿ytkownika obu aplikacji klienckich. W zwi¹zku z mnogoœci¹, utworzonych elementów interfejsu, zdecydowano siê na prezentacjê, tylko tych kluczowych.

\begin{figure}[ht]
 \centering
  \includegraphics[width=0.95\linewidth]{rys04/zrzut1}
 \caption{Widok panelu g³ównego aplikacji webowej}
 \label{fig:gui-webowa-zrzut1}
\end{figure}

\begin{figure}[ht]
 \centering
  \includegraphics[width=0.95\linewidth]{rys04/zrzut2}
 \caption{Widok panelu g³ównego aplikacji webowej (cz 2.)}
 \label{fig:gui-webowa-zrzut2}
\end{figure}

Na ilustracjach \ref{fig:gui-webowa-zrzut1} i \ref{fig:gui-webowa-zrzut2} ukazano widok panelu g³ównego aplikacji webowej. U¿ytkownik przechodzi z nich do innych widoków, wybieraj¹c okreœlony przycisk funkcjonalnoœci. Przyciski widoków mog¹ byæ aktywne lub niedostêpne, w zale¿noœci od posiadanych przez pracownika uprawnieñ.

\begin{figure}[ht]
 \centering
  \includegraphics[width=0.95\linewidth]{rys04/zrzut3}
 \caption{Widok funkcjonalnoœci przekazywania dokumentów pracownikowi}
 \label{fig:gui-webowa-zrzut3}
\end{figure}

Na rysunku \ref{fig:gui-webowa-zrzut3} widzimy modu³ przekazywania dokumentów pomiêdzy pracownikami. W momencie tworzenia tej ilustracji, zeskanowany zosta³ kod pracownika, a wczytywany zostaje barkod QR dokumentu. Poni¿ej widoku kamery, zlokalizowane s¹ dwa kontenery, prezentuj¹ce czas pozosta³y do zakoñczenia procedury skanowania oraz listê wczytanych dokumentów.

\begin{figure}[ht]
 \centering
  \includegraphics[width=0.95\linewidth]{rys04/zrzut4}
 \caption{Widok funkcjonalnoœci œledzenia dokumentów}
 \label{fig:gui-webowa-zrzut4}
\end{figure}

Ilustracja \ref{fig:gui-webowa-zrzut4} obrazuje widok œledzenia dokumentów. W ka¿dym wierszu tabeli, prezentowane s¹ informacje o dokumencie, jego aktualnym statusie w systemie, a tak¿e wszystkich akcjach na nim wykonanych. U¿ytkownik, posiadaj¹cy uprawnienia dostêpu do tego widoku, mo¿e ponadto wprowadziæ notê wyjaœniaj¹c¹ dla dokumentu (przycisk "`Wyjaœnij"'), co spowoduje archiwizacjê faktury po zakoñczeniu dnia pracy.

\begin{figure}[ht]
 \centering
  \includegraphics[width=0.95\linewidth]{rys04/zrzut5}
 \caption{Widok funkcjonalnoœci przegl¹dania notatek pracowników handlowych}
 \label{fig:gui-webowa-zrzut5}
\end{figure}

Przedstawiona grafika \ref{fig:gui-webowa-zrzut5} ukazuje widok modu³u przegl¹dania notatek handlowych. U¿ytkownik, w ramach tego widoku, po wybraniu pracownika oraz daty utworzenia notatek, mo¿e przegl¹daæ wszystkie wprowadzone przez pracownika wpisy informacyjne. W zale¿noœci od typu wpisu, ukazane na mapie punkty lokalizacyjne, charakteryzuj¹ siê odmienn¹ kolorystyk¹. Po wybraniu okreœlonego punktu na mapie, widoczne s¹ dane notatki dla tej lokalizacji.

\begin{figure}[ht]
 \centering
  \includegraphics[width=0.95\linewidth]{rys04/zrzut6}
 \caption{Widok funkcjonalnoœci planowania trasy dostawy - wybór lokalizacji}
 \label{fig:gui-webowa-zrzut6}
\end{figure}

Na ilustracji \ref{fig:gui-webowa-zrzut6}, widoczny jest element segmentu planowania trasy dostawy. Po lewej stronie widoku, dostêpne s¹ wszystkie dokumenty przypisane do zalogowanego pracownika, natomiast po prawej stronie, znajduje siê fragment mapy. Mapa ta, wykorzystywana jest do wyboru lokalizacji dostawy dla dokumentu, w sytuacji gdy dane faktury nie pozwol¹ na jej automatyczne uzyskanie.

\newpage

\begin{figure}[ht]
 \centering
  \includegraphics[width=0.95\linewidth]{rys04/zrzut7}
 \caption{Widok funkcjonalnoœci planowania trasy dostawy - rezultat}
 \label{fig:gui-webowa-zrzut7}
\end{figure}

Po wyborze wszystkich punktów lokalizacyjnych, uruchamiany jest algorytm wyliczania trasy dostawy. Z chwil¹ otrzymania wyniku dzia³ania algorytmu, ukazuje siê widok przedstawiony na ilustracji \ref{fig:gui-webowa-zrzut7}. Widzimy w nim listê kolejnych lokalizacji na drodze dostawy, a tak¿e mapê unaoczniaj¹c¹ sekwencjê odwiedzanych punktów. Po wybraniu dowolnego z punktów, wyœwietlana jest informacja o powi¹zanym dokumencie oraz danych adresowych.

\begin{figure}[ht]
 \centering
  \includegraphics[width=0.95\linewidth]{rys04/zrzut8}
 \caption{Widok funkcjonalnoœci komunikatora tekstowego}
 \label{fig:gui-webowa-zrzut8}
\end{figure}

Rysunek \ref{fig:gui-webowa-zrzut8}, prezentuje wygl¹d widoku wewnêtrznego komunikatora tekstowego. Wyró¿niæ mo¿emy w nim listê pracowników, z którymi chcemy rozpocz¹æ konwersacjê, a tak¿e okno wysy³anych wiadomoœci. Poza mo¿liwoœci¹ wprowadzania tekstu wiadomoœci, istnieje tak¿e funkcjonalnoœæ wyboru dokumentu, o którym chcemy "`wspomnieæ"' w wiadomoœci. Wprowadzenie wspomnienia dla faktury, skutkuje wyœwietleniem adekwatnej informacji, w widoku œledzenia dokumentów.

\newpage

\begin{figure}[ht]
  \centering
	\begin{tabular}{@{}ll@{}}
	a) & b) \\
  \includegraphics[width=0.3\textwidth]{rys04/mobilna/zrzut1} & 
	\includegraphics[width=0.3\textwidth]{rys04/mobilna/zrzut2}
	\end{tabular}
  \caption{Aktywnoœæ g³ówna aplikacji mobilnej a) lista dokumentów b) panel boczny}
  \label{fig:gui-mobilna-zrzut12}
\end{figure}

Na ilustracjach \ref{fig:gui-mobilna-zrzut12}a oraz \ref{fig:gui-mobilna-zrzut12}b, przedstawiona zosta³a aktywnoœæ g³ówna aplikacji mobilnej. Pierwsza z grafik, ukazuje widok listy dokumentów, ³adowany domyœlnie, po zalogowaniu siê do systemu. Na drugim rysunku natomiast, widzimy rozsuwany panel boczny, zawieraj¹cy wiêkszoœæ z dostêpnych funkcjonalnoœci aplikacji.

\begin{figure}[ht]
  \centering
	\begin{tabular}{l l l}
	a) & b) & c) \\
  \includegraphics[width=0.27\textwidth]{rys04/mobilna/zrzut3} & 
	\includegraphics[width=0.27\textwidth]{rys04/mobilna/zrzut4} &
	\includegraphics[width=0.27\textwidth]{rys04/mobilna/zrzut5}
	\end{tabular}
  \caption{Aktywnoœci wprowadzania danych a) zg³aszanie uwagi b) wpis kilometrów c) wpis notatki}
  \label{fig:gui-mobilna-zrzut345}
\end{figure}

W ramach rysunków \ref{fig:gui-mobilna-zrzut345}a, \ref{fig:gui-mobilna-zrzut345}b oraz \ref{fig:gui-mobilna-zrzut345}c, ukazane zosta³y aktywnoœci wprowadzania danych w aplikacji mobilnej. Pierwsza z nich, tyczy siê zg³aszania uwagi dotycz¹cej dokumentu. U¿ytkownik, po naciœniêciu czerwonego przycisku, znajduj¹cego siê przy fakturze, wprowadza zawartoœæ notatki uwagi, do przedstawionego pola tekstowego. Druga aktywnoœæ, zdefiniowana zosta³a w celu generowania adnotacji dotycz¹cych liczników kilometrów, w pojazdach firmy. W widoku tym, je¿eli do u¿ytkownika przypisany jest pojazd domyœlny, zostaje on wybrany z listy rozwijanej automatycznie. Trzecia z aktywnoœci, wykorzystywana jest do wprowadzania wpisów dotycz¹cych notatek handlowych. 

\begin{figure}[ht]
  \centering
	\begin{tabular}{l l l}
	a) & b) & c) \\
  \includegraphics[width=0.27\textwidth]{rys04/mobilna/zrzut6} & 
	\includegraphics[width=0.27\textwidth]{rys04/mobilna/zrzut8} &
	\includegraphics[width=0.27\textwidth]{rys04/mobilna/zrzut7}
	\end{tabular}
  \caption{Aktywnoœci planowania trasy dostawy a) lista dokumentów b) wybór lokalizacji c) rezultat obliczeñ}
  \label{fig:gui-mobilna-zrzut678}
\end{figure}

Na grafikach \ref{fig:gui-mobilna-zrzut678}a, \ref{fig:gui-mobilna-zrzut678}b oraz \ref{fig:gui-mobilna-zrzut678}c, widzimy widoki aplikacji mobilnej, dotycz¹ce wyznaczania trasy dostawy. W pierwszym widoku, zawarta jest lista przypisanych do pracownika dokumentów. Po wybraniu jednej z faktur, je¿eli nie posiada ona przypisanej automatycznie lokalizacji, przechodzimy do aktywnoœci drugiej. W ramach tej aktywnoœci, u¿ytkownik mo¿e wyszukaæ dowoln¹ lokalizacjê, a nastêpnie przypisaæ j¹ do dokumentu. Widok trzeci natomiast, reprezentuje rezultat, w postaci ustalonej trasy dostawy. Po klikniêciu przycisku "`zapisz"', u¿ytkownik kierowany jest do panelu g³ównego, a dokumenty w nim zawarte, sortuj¹ siê w kolejnoœci zgodnej z tras¹ dostawy.

\newpage

\begin{figure}[ht]
  \centering
	\begin{tabular}{@{}ll@{}}
	a) & b) \\
  \includegraphics[width=0.3\textwidth]{rys04/mobilna/zrzut9} & 
	\includegraphics[width=0.3\textwidth]{rys04/mobilna/zrzut10}
	\end{tabular}
  \caption{Aktywnoœæ komunikatora aplikacji mobilnej a) lista pracowników b) wymiana wiadomoœci}
  \label{fig:gui-mobilna-zrzut910}
\end{figure}

Ostatnie z przedstawionych grafik (tj. grafika \ref{fig:gui-mobilna-zrzut910}a oraz \ref{fig:gui-mobilna-zrzut910}b), ukazuj¹ funkcjonalnoœæ wewnêtrznego komunikatora tekstowego aplikacji mobilnej. Wyró¿niæ mo¿emy tutaj widok listy pracowników, w którymi mo¿na rozpocz¹æ konwersacjê, a tak¿e komponent przedstawiaj¹cy rozmowê z konkretnym u¿ytkownikiem.
